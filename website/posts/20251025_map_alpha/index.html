<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2025-10-25">

<title>purrr::mapを使ってpsych::alphaを一気に処理する – さかいの備忘録</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark-1c1298d4aec20b932e1c4c12e9ecd263.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-0bd6bd4cbde67017807ea45c3bc8f802.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../styles.css">
<meta property="og:title" content="purrr::mapを使ってpsych::alphaを一気に処理する – さかいの備忘録">
<meta property="og:description" content="purrr::map()の中でpsych::alpha()を使って、元のdfから一気にα係数の処理をしてみた。">
<meta property="og:site_name" content="さかいの備忘録">
<meta name="twitter:title" content="purrr::mapを使ってpsych::alphaを一気に処理する – さかいの備忘録">
<meta name="twitter:description" content="purrr::map()の中でpsych::alpha()を使って、元のdfから一気にα係数の処理をしてみた。">
<meta name="twitter:card" content="summary">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">さかいの備忘録</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../content.html"> 
<span class="menu-text">Content</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://x.com/tsakai_psych" target="_blank"> <i class="bi bi-twitter-x" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://researchmap.jp/takutosakai" target="_blank"> 
<span class="menu-text">researchmap</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/tsakai-psych" target="_blank"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-page-left">
      <h1 class="title">purrr::mapを使ってpsych::alphaを一気に処理する</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">R memo</div>
                <div class="quarto-category">preprocess</div>
                <div class="quarto-category">analysis</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta column-page-left">

      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">2025-10-25</p>
      </div>
    </div>
    
      
    </div>
    
  <div>
    <div class="abstract">
      <div class="block-title">Abstract</div>
      <p><code>purrr::map()</code>の中で<code>psych::alpha()</code>を使って、元のdfから一気にα係数の処理をしてみた。</p>
    </div>
  </div>
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#packages" id="toc-packages" class="nav-link active" data-scroll-target="#packages">Packages</a></li>
  <li><a href="#content" id="toc-content" class="nav-link" data-scroll-target="#content">Content</a>
  <ul class="collapse">
  <li><a href="#やりやすいデータの場合" id="toc-やりやすいデータの場合" class="nav-link" data-scroll-target="#やりやすいデータの場合">やりやすいデータの場合</a></li>
  <li><a href="#やりやすくなさそうなデータの場合" id="toc-やりやすくなさそうなデータの場合" class="nav-link" data-scroll-target="#やりやすくなさそうなデータの場合">やりやすくなさそうなデータの場合</a></li>
  </ul></li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion">Conclusion</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block column-page-left" id="quarto-document-content">





<section id="packages" class="level1">
<h1>Packages</h1>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1"></a>pacman<span class="sc">::</span><span class="fu">p_load</span>(</span>
<span id="cb1-2"><a href="#cb1-2"></a>  tidyverse,</span>
<span id="cb1-3"><a href="#cb1-3"></a>  psych</span>
<span id="cb1-4"><a href="#cb1-4"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="content" class="level1">
<h1>Content</h1>
<p>デモデータとして<code>psych::bfi</code>を使います。</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1"></a><span class="fu">data</span>(bfi, <span class="at">package =</span> <span class="st">"psych"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>ロードされるデータのうち、<code>bfi</code>は2800行28列のデータで、列の最初の25項目は5因子に分かれるパーソナリティに関する項目が各5つずつ、残りの3列は性別、学歴、年齢が含まれています。</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1"></a><span class="fu">str</span>(bfi)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>'data.frame':   2800 obs. of  28 variables:
 $ A1       : int  2 2 5 4 2 6 2 4 4 2 ...
 $ A2       : int  4 4 4 4 3 6 5 3 3 5 ...
 $ A3       : int  3 5 5 6 3 5 5 1 6 6 ...
 $ A4       : int  4 2 4 5 4 6 3 5 3 6 ...
 $ A5       : int  4 5 4 5 5 5 5 1 3 5 ...
 $ C1       : int  2 5 4 4 4 6 5 3 6 6 ...
 $ C2       : int  3 4 5 4 4 6 4 2 6 5 ...
 $ C3       : int  3 4 4 3 5 6 4 4 3 6 ...
 $ C4       : int  4 3 2 5 3 1 2 2 4 2 ...
 $ C5       : int  4 4 5 5 2 3 3 4 5 1 ...
 $ E1       : int  3 1 2 5 2 2 4 3 5 2 ...
 $ E2       : int  3 1 4 3 2 1 3 6 3 2 ...
 $ E3       : int  3 6 4 4 5 6 4 4 NA 4 ...
 $ E4       : int  4 4 4 4 4 5 5 2 4 5 ...
 $ E5       : int  4 3 5 4 5 6 5 1 3 5 ...
 $ N1       : int  3 3 4 2 2 3 1 6 5 5 ...
 $ N2       : int  4 3 5 5 3 5 2 3 5 5 ...
 $ N3       : int  2 3 4 2 4 2 2 2 2 5 ...
 $ N4       : int  2 5 2 4 4 2 1 6 3 2 ...
 $ N5       : int  3 5 3 1 3 3 1 4 3 4 ...
 $ O1       : int  3 4 4 3 3 4 5 3 6 5 ...
 $ O2       : int  6 2 2 3 3 3 2 2 6 1 ...
 $ O3       : int  3 4 5 4 4 5 5 4 6 5 ...
 $ O4       : int  4 3 5 3 3 6 6 5 6 5 ...
 $ O5       : int  3 3 2 5 3 1 1 3 1 2 ...
 $ gender   : int  1 2 2 2 1 2 1 1 1 2 ...
 $ education: int  NA NA NA NA NA 3 NA 2 1 NA ...
 $ age      : int  16 18 17 17 17 21 18 19 19 17 ...</code></pre>
</div>
</div>
<p><code>bfi.keys</code>の方は、25項目のパーソナリティに関する項目がそれぞれのど下位尺度を構成するのかという情報がlist形式で収められています。頭に-がついているのは、逆転項目のしるしです。</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1"></a>bfi.keys</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>$agree
[1] "-A1" "A2"  "A3"  "A4"  "A5" 

$conscientious
[1] "C1"  "C2"  "C3"  "-C4" "-C5"

$extraversion
[1] "-E1" "-E2" "E3"  "E4"  "E5" 

$neuroticism
[1] "N1" "N2" "N3" "N4" "N5"

$openness
[1] "O1"  "-O2" "O3"  "O4"  "-O5"</code></pre>
</div>
</div>
<p>このデータのそれぞれの下位尺度ごとにα係数を求めたいとなった場合、ふつうはこんな感じになると思います。</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1"></a>res_alpha_a <span class="ot">&lt;-</span> bfi <span class="sc">|&gt;</span></span>
<span id="cb7-2"><a href="#cb7-2"></a>  <span class="fu">select</span>(A1<span class="sc">:</span>A5) <span class="sc">|&gt;</span></span>
<span id="cb7-3"><a href="#cb7-3"></a>  psych<span class="sc">::</span><span class="fu">alpha</span>(</span>
<span id="cb7-4"><a href="#cb7-4"></a>    <span class="at">keys =</span> <span class="st">"A1"</span></span>
<span id="cb7-5"><a href="#cb7-5"></a>  )</span>
<span id="cb7-6"><a href="#cb7-6"></a></span>
<span id="cb7-7"><a href="#cb7-7"></a>res_alpha_a</span>
<span id="cb7-8"><a href="#cb7-8"></a></span>
<span id="cb7-9"><a href="#cb7-9"></a>res_alpha_c <span class="ot">&lt;-</span> bfi <span class="sc">|&gt;</span></span>
<span id="cb7-10"><a href="#cb7-10"></a>  <span class="fu">select</span>(C1<span class="sc">:</span>C5) <span class="sc">|&gt;</span></span>
<span id="cb7-11"><a href="#cb7-11"></a>  psych<span class="sc">::</span><span class="fu">alpha</span>(</span>
<span id="cb7-12"><a href="#cb7-12"></a>    <span class="at">keys =</span> <span class="fu">c</span>(<span class="st">"C4"</span>, <span class="st">"C5"</span>)</span>
<span id="cb7-13"><a href="#cb7-13"></a>  )</span>
<span id="cb7-14"><a href="#cb7-14"></a></span>
<span id="cb7-15"><a href="#cb7-15"></a>res_alpha_c</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>列名選択と逆転項目の指定を自分で頑張る方法です。これを5因子分繰り返します。可読性は悪くないので、これでも十分な気がします。</p>
<p>ただ、せっかくなのでほとんどをRに任せて１回の処理でできたら、それもそれでいい気がします。ということで試してみました。</p>
<section id="やりやすいデータの場合" class="level2">
<h2 class="anchored" data-anchor-id="やりやすいデータの場合">やりやすいデータの場合</h2>
<p>まず、処理しやすいようにデータをlong型にします。ついでに<code>tibble::rownames_to_column()</code>でrownameをid列に変えておきます。id列がないと<code>tidyr::pivot_wider()</code>出来なくなるので、少なくともその処理の前にはやっておきます。</p>
<div class="cell">
<div class="sourceCode cell-code" id="annotated-cell-6"><pre class="sourceCode numberSource r code-annotation-code number-lines code-with-copy code-annotated"><code class="sourceCode r"><span id="annotated-cell-6-1"><a href="#annotated-cell-6-1"></a>bfi <span class="sc">|&gt;</span></span>
<span id="annotated-cell-6-2"><a href="#annotated-cell-6-2"></a>  <span class="fu">rownames_to_column</span>(<span class="at">var =</span> <span class="st">"id"</span>) <span class="sc">|&gt;</span></span>
<span id="annotated-cell-6-3"><a href="#annotated-cell-6-3"></a>  <span class="fu">pivot_longer</span>(</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-6" data-target-annotation="1" onclick="event.preventDefault();">1</a><span id="annotated-cell-6-4" class="code-annotation-target"><a href="#annotated-cell-6-4"></a>    <span class="at">cols =</span> <span class="fu">matches</span>(<span class="st">"</span><span class="sc">\\</span><span class="st">w</span><span class="sc">\\</span><span class="st">d"</span>),</span>
<span id="annotated-cell-6-5"><a href="#annotated-cell-6-5"></a>    <span class="at">names_to =</span> <span class="st">"items"</span></span>
<span id="annotated-cell-6-6"><a href="#annotated-cell-6-6"></a>  )</span><div class="code-annotation-gutter-bg"></div><div class="code-annotation-gutter"></div></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-annotation">
<dl class="code-annotation-container-grid">
<dt data-target-cell="annotated-cell-6" data-target-annotation="1">1</dt>
<dd>
<span data-code-cell="annotated-cell-6" data-code-lines="4" data-code-annotation="1">引数<code>cols</code>はtidy-selectの文法なので<code>-c(id, gender, education, age)</code>でもいいです。longにしたい列名が「文字1文字数字1文字」なのがわかっているので、<code>dplyr::matches()</code>で正規表現を使って絞りました。</span>
</dd>
</dl>
</div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 70,000 × 6
   id    gender education   age items value
   &lt;chr&gt;  &lt;int&gt;     &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt;
 1 61617      1        NA    16 A1        2
 2 61617      1        NA    16 A2        4
 3 61617      1        NA    16 A3        3
 4 61617      1        NA    16 A4        4
 5 61617      1        NA    16 A5        4
 6 61617      1        NA    16 C1        2
 7 61617      1        NA    16 C2        3
 8 61617      1        NA    16 C3        3
 9 61617      1        NA    16 C4        4
10 61617      1        NA    16 C5        4
# ℹ 69,990 more rows</code></pre>
</div>
</div>
<p>次に、nest用の列を作ってnestします。今回は列名に下位尺度が入っているので、それを抽出すれば簡単にnest用の列が完成です。やりやすいデータとはこのことを言っています。</p>
<div class="cell">
<div class="sourceCode cell-code" id="annotated-cell-7"><pre class="sourceCode numberSource r code-annotation-code number-lines code-with-copy code-annotated"><code class="sourceCode r"><span id="annotated-cell-7-1"><a href="#annotated-cell-7-1"></a>bfi <span class="sc">|&gt;</span></span>
<span id="annotated-cell-7-2"><a href="#annotated-cell-7-2"></a>  <span class="fu">rownames_to_column</span>(<span class="at">var =</span> <span class="st">"id"</span>) <span class="sc">|&gt;</span></span>
<span id="annotated-cell-7-3"><a href="#annotated-cell-7-3"></a>  <span class="fu">pivot_longer</span>(</span>
<span id="annotated-cell-7-4"><a href="#annotated-cell-7-4"></a>    <span class="at">cols =</span> <span class="fu">matches</span>(<span class="st">"</span><span class="sc">\\</span><span class="st">w</span><span class="sc">\\</span><span class="st">d"</span>),</span>
<span id="annotated-cell-7-5"><a href="#annotated-cell-7-5"></a>    <span class="at">names_to =</span> <span class="st">"items"</span></span>
<span id="annotated-cell-7-6"><a href="#annotated-cell-7-6"></a>  ) <span class="sc">|&gt;</span></span>
<span id="annotated-cell-7-7"><a href="#annotated-cell-7-7"></a>  <span class="fu">mutate</span>(</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-7" data-target-annotation="1" onclick="event.preventDefault();">1</a><span id="annotated-cell-7-8" class="code-annotation-target"><a href="#annotated-cell-7-8"></a>    <span class="at">nest_key =</span> <span class="fu">str_extract</span>(items, <span class="st">"^."</span>) <span class="sc">|&gt;</span></span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-7" data-target-annotation="2" onclick="event.preventDefault();">2</a><span id="annotated-cell-7-9" class="code-annotation-target"><a href="#annotated-cell-7-9"></a>      <span class="fu">tolower</span>()</span>
<span id="annotated-cell-7-10"><a href="#annotated-cell-7-10"></a>  ) <span class="sc">|&gt;</span></span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-7" data-target-annotation="3" onclick="event.preventDefault();">3</a><span id="annotated-cell-7-11" class="code-annotation-target"><a href="#annotated-cell-7-11"></a>  <span class="fu">nest</span>(<span class="at">.by =</span> nest_key)</span><div class="code-annotation-gutter-bg"></div><div class="code-annotation-gutter"></div></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-annotation">
<dl class="code-annotation-container-grid">
<dt data-target-cell="annotated-cell-7" data-target-annotation="1">1</dt>
<dd>
<span data-code-cell="annotated-cell-7" data-code-lines="8" data-code-annotation="1">items（列名のベクトル）の各要素から最初の一文字だけ抜ければいいので、<code>stringr::str_extract()</code>でいいです。</span>
</dd>
<dt data-target-cell="annotated-cell-7" data-target-annotation="2">2</dt>
<dd>
<span data-code-cell="annotated-cell-7" data-code-lines="9" data-code-annotation="2">あとで<code>bfi.keys</code>から抽出しやすくすために、小文字にします。</span>
</dd>
<dt data-target-cell="annotated-cell-7" data-target-annotation="3">3</dt>
<dd>
<span data-code-cell="annotated-cell-7" data-code-lines="11" data-code-annotation="3">nestに使った列以外の残りは、引数<code>.keys</code>を指定しなければdata列にまとまります。</span>
</dd>
</dl>
</div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 5 × 2
  nest_key data                 
  &lt;chr&gt;    &lt;list&gt;               
1 a        &lt;tibble [14,000 × 6]&gt;
2 c        &lt;tibble [14,000 × 6]&gt;
3 e        &lt;tibble [14,000 × 6]&gt;
4 n        &lt;tibble [14,000 × 6]&gt;
5 o        &lt;tibble [14,000 × 6]&gt;</code></pre>
</div>
</div>
<p>nestされたデータを処理します。data列はlistなので、中の各要素を処理したいときは<code>purrr::map()</code>が使えます。data列の各要素はデータフレームで、しかもaの行はAで始まる項目だけ、cの行はCで始まる項目だけ、eの行は…のlongデータになっています。そのため、<code>map()</code>の中でwide型に直して必要列以外取り除き、<code>psych::alpha()</code>に入れてあげればいいわけです。</p>
<div class="cell">
<div class="sourceCode cell-code" id="annotated-cell-8"><pre class="sourceCode numberSource r code-annotation-code number-lines code-with-copy code-annotated"><code class="sourceCode r"><span id="annotated-cell-8-1"><a href="#annotated-cell-8-1"></a>bfi <span class="sc">|&gt;</span></span>
<span id="annotated-cell-8-2"><a href="#annotated-cell-8-2"></a>  <span class="fu">rownames_to_column</span>(<span class="at">var =</span> <span class="st">"id"</span>) <span class="sc">|&gt;</span></span>
<span id="annotated-cell-8-3"><a href="#annotated-cell-8-3"></a>  <span class="fu">pivot_longer</span>(</span>
<span id="annotated-cell-8-4"><a href="#annotated-cell-8-4"></a>    <span class="at">cols =</span> <span class="fu">matches</span>(<span class="st">"</span><span class="sc">\\</span><span class="st">w</span><span class="sc">\\</span><span class="st">d"</span>),</span>
<span id="annotated-cell-8-5"><a href="#annotated-cell-8-5"></a>    <span class="at">names_to =</span> <span class="st">"items"</span></span>
<span id="annotated-cell-8-6"><a href="#annotated-cell-8-6"></a>  ) <span class="sc">|&gt;</span></span>
<span id="annotated-cell-8-7"><a href="#annotated-cell-8-7"></a>  <span class="fu">mutate</span>(</span>
<span id="annotated-cell-8-8"><a href="#annotated-cell-8-8"></a>    <span class="at">nest_key =</span> <span class="fu">str_extract</span>(items, <span class="st">"^."</span>) <span class="sc">|&gt;</span></span>
<span id="annotated-cell-8-9"><a href="#annotated-cell-8-9"></a>      <span class="fu">tolower</span>()</span>
<span id="annotated-cell-8-10"><a href="#annotated-cell-8-10"></a>  ) <span class="sc">|&gt;</span></span>
<span id="annotated-cell-8-11"><a href="#annotated-cell-8-11"></a>  <span class="fu">nest</span>(<span class="at">.by =</span> nest_key) <span class="sc">|&gt;</span></span>
<span id="annotated-cell-8-12"><a href="#annotated-cell-8-12"></a>  <span class="fu">mutate</span>(</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-8" data-target-annotation="1" onclick="event.preventDefault();">1</a><span id="annotated-cell-8-13" class="code-annotation-target"><a href="#annotated-cell-8-13"></a>    <span class="at">bfi_key_name =</span> <span class="fu">str_subset</span>(</span>
<span id="annotated-cell-8-14"><a href="#annotated-cell-8-14"></a>      <span class="fu">names</span>(bfi.keys),</span>
<span id="annotated-cell-8-15"><a href="#annotated-cell-8-15"></a>      <span class="at">pattern =</span> <span class="fu">paste0</span>(<span class="st">"^"</span>, nest_key)</span>
<span id="annotated-cell-8-16"><a href="#annotated-cell-8-16"></a>    ),</span>
<span id="annotated-cell-8-17"><a href="#annotated-cell-8-17"></a>    <span class="at">res_alpha =</span> <span class="fu">map</span>(</span>
<span id="annotated-cell-8-18"><a href="#annotated-cell-8-18"></a>      <span class="at">.x =</span> data,</span>
<span id="annotated-cell-8-19"><a href="#annotated-cell-8-19"></a>      <span class="at">.f =</span> \(x) {</span>
<span id="annotated-cell-8-20"><a href="#annotated-cell-8-20"></a>         x <span class="sc">|&gt;</span></span>
<span id="annotated-cell-8-21"><a href="#annotated-cell-8-21"></a>          <span class="fu">pivot_wider</span>(</span>
<span id="annotated-cell-8-22"><a href="#annotated-cell-8-22"></a>            <span class="at">names_from =</span> items,</span>
<span id="annotated-cell-8-23"><a href="#annotated-cell-8-23"></a>            <span class="at">values_from =</span> value</span>
<span id="annotated-cell-8-24"><a href="#annotated-cell-8-24"></a>          ) <span class="sc">|&gt;</span></span>
<span id="annotated-cell-8-25"><a href="#annotated-cell-8-25"></a>          <span class="fu">select</span>(<span class="fu">matches</span>(<span class="st">"</span><span class="sc">\\</span><span class="st">w</span><span class="sc">\\</span><span class="st">d"</span>)) <span class="sc">|&gt;</span></span>
<span id="annotated-cell-8-26"><a href="#annotated-cell-8-26"></a>          psych<span class="sc">::</span><span class="fu">alpha</span>(</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-8" data-target-annotation="2" onclick="event.preventDefault();">2</a><span id="annotated-cell-8-27" class="code-annotation-target"><a href="#annotated-cell-8-27"></a>            <span class="at">keys =</span> bfi.keys[[bfi_key_name]] <span class="sc">|&gt;</span></span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-8" data-target-annotation="3" onclick="event.preventDefault();">3</a><span id="annotated-cell-8-28" class="code-annotation-target"><a href="#annotated-cell-8-28"></a>              <span class="fu">str_subset</span>(<span class="at">pattern =</span> <span class="st">"^-"</span>) <span class="sc">|&gt;</span></span>
<span id="annotated-cell-8-29"><a href="#annotated-cell-8-29"></a>              <span class="fu">str_remove</span>(<span class="at">pattern =</span> <span class="st">"^-"</span>)</span>
<span id="annotated-cell-8-30"><a href="#annotated-cell-8-30"></a>          )</span>
<span id="annotated-cell-8-31"><a href="#annotated-cell-8-31"></a>      }</span>
<span id="annotated-cell-8-32"><a href="#annotated-cell-8-32"></a>    ) <span class="sc">|&gt;</span></span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-8" data-target-annotation="4" onclick="event.preventDefault();">4</a><span id="annotated-cell-8-33" class="code-annotation-target"><a href="#annotated-cell-8-33"></a>      <span class="fu">set_names</span>(bfi_key_name),</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-8" data-target-annotation="5" onclick="event.preventDefault();">5</a><span id="annotated-cell-8-34" class="code-annotation-target"><a href="#annotated-cell-8-34"></a>    <span class="at">.by =</span> nest_key</span>
<span id="annotated-cell-8-35"><a href="#annotated-cell-8-35"></a>  )</span><div class="code-annotation-gutter-bg"></div><div class="code-annotation-gutter"></div></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-annotation">
<dl class="code-annotation-container-grid">
<dt data-target-cell="annotated-cell-8" data-target-annotation="1">1</dt>
<dd>
<span data-code-cell="annotated-cell-8" data-code-lines="13,14,15,16" data-code-annotation="1"><code>alpha()</code>の中で<code>bfi.keys</code>の要素名を使えるようにしたいので、ここで抜き出しておきます。</span>
</dd>
<dt data-target-cell="annotated-cell-8" data-target-annotation="2">2</dt>
<dd>
<span data-code-cell="annotated-cell-8" data-code-lines="27" data-code-annotation="2">まさに上の処理で抜き出した要素名をここで使います。</span>
</dd>
<dt data-target-cell="annotated-cell-8" data-target-annotation="3">3</dt>
<dd>
<span data-code-cell="annotated-cell-8" data-code-lines="28,29" data-code-annotation="3">引数<code>keys</code>は、逆転する項目の項目名を文字列ベクトルで入れるか、逆転する項目は-1、そのままの項目は1にした数値ベクトルを入れます。今回は前者で入れるので、<code>bfi.keys</code>の各要素（文字列ベクトル）のうち、<code>stringr::str_subset()</code>を使って-で始まる項目だけを抽出して、<code>str_remove()</code>で-を取り除きます。</span>
</dd>
<dt data-target-cell="annotated-cell-8" data-target-annotation="4">4</dt>
<dd>
<span data-code-cell="annotated-cell-8" data-code-lines="33" data-code-annotation="4"><code>map()</code>の戻り値のlistに名前を付けたいので<code>map() |&gt; purrr::set_names()</code>とします。nestデータのほかの列の要素を使えるので、<code>dplyr::group_map() |&gt; set_names()</code>よりもいい気がします。</span>
</dd>
<dt data-target-cell="annotated-cell-8" data-target-annotation="5">5</dt>
<dd>
<span data-code-cell="annotated-cell-8" data-code-lines="34" data-code-annotation="5">引数<code>.by</code>にnest_key列を指定して、実質rowwise処理をします。これを指定することで、(2)の処理で<code>[[bfi_key_name]]</code>のところにbfi_key_name列の要素が1つだけ入ります。これがないと、(2)の処理で要素5の文字列ベクトル<code>c（"agree", "conscientious", ...）</code>が<code>[[</code>の中に入ってしまうのでエラーになります。</span>
</dd>
</dl>
</div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 5 × 4
  nest_key data                  bfi_key_name  res_alpha   
  &lt;chr&gt;    &lt;list&gt;                &lt;chr&gt;         &lt;named list&gt;
1 a        &lt;tibble [14,000 × 6]&gt; agree         &lt;psych&gt;     
2 c        &lt;tibble [14,000 × 6]&gt; conscientious &lt;psych&gt;     
3 e        &lt;tibble [14,000 × 6]&gt; extraversion  &lt;psych&gt;     
4 n        &lt;tibble [14,000 × 6]&gt; neuroticism   &lt;psych&gt;     
5 o        &lt;tibble [14,000 × 6]&gt; openness      &lt;psych&gt;     </code></pre>
</div>
</div>
<p>最後に結果が詰まったres_alpha列だけ取り出します。データフレームからある1列の要素を取り出すときは<code>dplyr::pull()</code>が使えます。res_alpha列は<code>map()</code>を使って作ったので、各下位尺度のα係数が入ったlistが返ってきます。</p>
<div class="cell">
<div class="sourceCode cell-code" id="annotated-cell-9"><pre class="sourceCode numberSource r code-annotation-code number-lines code-with-copy code-annotated"><code class="sourceCode r"><span id="annotated-cell-9-1"><a href="#annotated-cell-9-1"></a>bfi <span class="sc">|&gt;</span></span>
<span id="annotated-cell-9-2"><a href="#annotated-cell-9-2"></a>  <span class="fu">rownames_to_column</span>(<span class="at">var =</span> <span class="st">"id"</span>) <span class="sc">|&gt;</span></span>
<span id="annotated-cell-9-3"><a href="#annotated-cell-9-3"></a>  <span class="fu">pivot_longer</span>(</span>
<span id="annotated-cell-9-4"><a href="#annotated-cell-9-4"></a>    <span class="at">cols =</span> <span class="fu">matches</span>(<span class="st">"</span><span class="sc">\\</span><span class="st">w</span><span class="sc">\\</span><span class="st">d"</span>),</span>
<span id="annotated-cell-9-5"><a href="#annotated-cell-9-5"></a>    <span class="at">names_to =</span> <span class="st">"items"</span></span>
<span id="annotated-cell-9-6"><a href="#annotated-cell-9-6"></a>  ) <span class="sc">|&gt;</span></span>
<span id="annotated-cell-9-7"><a href="#annotated-cell-9-7"></a>  <span class="fu">mutate</span>(</span>
<span id="annotated-cell-9-8"><a href="#annotated-cell-9-8"></a>    <span class="at">nest_key =</span> <span class="fu">str_extract</span>(items, <span class="st">"^."</span>) <span class="sc">|&gt;</span></span>
<span id="annotated-cell-9-9"><a href="#annotated-cell-9-9"></a>      <span class="fu">tolower</span>()</span>
<span id="annotated-cell-9-10"><a href="#annotated-cell-9-10"></a>  ) <span class="sc">|&gt;</span></span>
<span id="annotated-cell-9-11"><a href="#annotated-cell-9-11"></a>  <span class="fu">nest</span>(<span class="at">.by =</span> nest_key) <span class="sc">|&gt;</span></span>
<span id="annotated-cell-9-12"><a href="#annotated-cell-9-12"></a>  <span class="fu">mutate</span>(</span>
<span id="annotated-cell-9-13"><a href="#annotated-cell-9-13"></a>    <span class="at">bfi_key_name =</span> <span class="fu">str_subset</span>(</span>
<span id="annotated-cell-9-14"><a href="#annotated-cell-9-14"></a>      <span class="fu">names</span>(bfi.keys),</span>
<span id="annotated-cell-9-15"><a href="#annotated-cell-9-15"></a>      <span class="at">pattern =</span> <span class="fu">paste0</span>(<span class="st">"^"</span>, nest_key)</span>
<span id="annotated-cell-9-16"><a href="#annotated-cell-9-16"></a>    ),</span>
<span id="annotated-cell-9-17"><a href="#annotated-cell-9-17"></a>    <span class="at">res_alpha =</span> <span class="fu">map</span>(</span>
<span id="annotated-cell-9-18"><a href="#annotated-cell-9-18"></a>      <span class="at">.x =</span> data,</span>
<span id="annotated-cell-9-19"><a href="#annotated-cell-9-19"></a>      <span class="at">.f =</span> \(x) {</span>
<span id="annotated-cell-9-20"><a href="#annotated-cell-9-20"></a>         x <span class="sc">|&gt;</span></span>
<span id="annotated-cell-9-21"><a href="#annotated-cell-9-21"></a>          <span class="fu">pivot_wider</span>(</span>
<span id="annotated-cell-9-22"><a href="#annotated-cell-9-22"></a>            <span class="at">names_from =</span> items,</span>
<span id="annotated-cell-9-23"><a href="#annotated-cell-9-23"></a>            <span class="at">values_from =</span> value</span>
<span id="annotated-cell-9-24"><a href="#annotated-cell-9-24"></a>          ) <span class="sc">|&gt;</span></span>
<span id="annotated-cell-9-25"><a href="#annotated-cell-9-25"></a>          <span class="fu">select</span>(<span class="fu">matches</span>(<span class="st">"</span><span class="sc">\\</span><span class="st">w</span><span class="sc">\\</span><span class="st">d"</span>)) <span class="sc">|&gt;</span></span>
<span id="annotated-cell-9-26"><a href="#annotated-cell-9-26"></a>          psych<span class="sc">::</span><span class="fu">alpha</span>(</span>
<span id="annotated-cell-9-27"><a href="#annotated-cell-9-27"></a>            <span class="at">keys =</span> bfi.keys[[bfi_key_name]] <span class="sc">|&gt;</span> </span>
<span id="annotated-cell-9-28"><a href="#annotated-cell-9-28"></a>              <span class="fu">str_subset</span>(<span class="at">pattern =</span> <span class="st">"^-"</span>) <span class="sc">|&gt;</span> </span>
<span id="annotated-cell-9-29"><a href="#annotated-cell-9-29"></a>              <span class="fu">str_remove</span>(<span class="at">pattern =</span> <span class="st">"^-"</span>)</span>
<span id="annotated-cell-9-30"><a href="#annotated-cell-9-30"></a>          )</span>
<span id="annotated-cell-9-31"><a href="#annotated-cell-9-31"></a>      }</span>
<span id="annotated-cell-9-32"><a href="#annotated-cell-9-32"></a>    ) <span class="sc">|&gt;</span></span>
<span id="annotated-cell-9-33"><a href="#annotated-cell-9-33"></a>      <span class="fu">set_names</span>(bfi_key_name),</span>
<span id="annotated-cell-9-34"><a href="#annotated-cell-9-34"></a>    <span class="at">.by =</span> nest_key</span>
<span id="annotated-cell-9-35"><a href="#annotated-cell-9-35"></a>  ) <span class="sc">|&gt;</span></span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-9" data-target-annotation="1" onclick="event.preventDefault();">1</a><span id="annotated-cell-9-36" class="code-annotation-target"><a href="#annotated-cell-9-36"></a>  <span class="fu">pull</span>(res_alpha)</span><div class="code-annotation-gutter-bg"></div><div class="code-annotation-gutter"></div></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-annotation">
<dl class="code-annotation-container-grid">
<dt data-target-cell="annotated-cell-9" data-target-annotation="1">1</dt>
<dd>
<span data-code-cell="annotated-cell-9" data-code-lines="36" data-code-annotation="1"><code>pull</code>は最後に作られた列を返すので、実は<code>pull()</code>だけでもres_alpha列を引っ張ってこれます。</span>
</dd>
</dl>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>$agree

Reliability analysis   
Call: psych::alpha(x = select(pivot_wider(x, names_from = items, values_from = value), 
    matches("\\w\\d")), keys = str_remove(str_subset(bfi.keys[[bfi_key_name]], 
    pattern = "^-"), pattern = "^-"))

  raw_alpha std.alpha G6(smc) average_r S/N   ase mean  sd median_r
       0.7      0.71    0.68      0.33 2.5 0.009  4.7 0.9     0.34

    95% confidence boundaries 
         lower alpha upper
Feldt     0.69   0.7  0.72
Duhachek  0.69   0.7  0.72

 Reliability if an item is dropped:
    raw_alpha std.alpha G6(smc) average_r S/N alpha se  var.r med.r
A1-      0.72      0.72    0.67      0.40 2.6   0.0087 0.0065  0.38
A2       0.62      0.63    0.58      0.29 1.7   0.0119 0.0168  0.29
A3       0.60      0.61    0.56      0.28 1.6   0.0124 0.0094  0.32
A4       0.69      0.69    0.65      0.36 2.3   0.0098 0.0157  0.37
A5       0.64      0.66    0.60      0.32 1.9   0.0111 0.0125  0.34

 Item statistics 
       n raw.r std.r r.cor r.drop mean  sd
A1- 2784  0.58  0.57  0.38   0.31  4.6 1.4
A2  2773  0.73  0.75  0.67   0.56  4.8 1.2
A3  2774  0.76  0.77  0.71   0.59  4.6 1.3
A4  2781  0.65  0.63  0.47   0.39  4.7 1.5
A5  2784  0.69  0.70  0.59   0.49  4.6 1.3

Non missing response frequency for each item
      1    2    3    4    5    6 miss
A1 0.33 0.29 0.14 0.12 0.08 0.03 0.01
A2 0.02 0.05 0.05 0.20 0.37 0.31 0.01
A3 0.03 0.06 0.07 0.20 0.36 0.27 0.01
A4 0.05 0.08 0.07 0.16 0.24 0.41 0.01
A5 0.02 0.07 0.09 0.22 0.35 0.25 0.01

$conscientious

Reliability analysis   
Call: psych::alpha(x = select(pivot_wider(x, names_from = items, values_from = value), 
    matches("\\w\\d")), keys = str_remove(str_subset(bfi.keys[[bfi_key_name]], 
    pattern = "^-"), pattern = "^-"))

  raw_alpha std.alpha G6(smc) average_r S/N    ase mean   sd median_r
      0.73      0.73    0.69      0.35 2.7 0.0081  4.3 0.95     0.34

    95% confidence boundaries 
         lower alpha upper
Feldt     0.71  0.73  0.74
Duhachek  0.71  0.73  0.74

 Reliability if an item is dropped:
    raw_alpha std.alpha G6(smc) average_r S/N alpha se  var.r med.r
C1       0.69      0.70    0.64      0.36 2.3   0.0093 0.0037  0.35
C2       0.67      0.68    0.62      0.34 2.1   0.0099 0.0056  0.34
C3       0.69      0.69    0.64      0.36 2.3   0.0096 0.0070  0.36
C4-      0.65      0.66    0.60      0.33 2.0   0.0107 0.0037  0.32
C5-      0.69      0.69    0.63      0.36 2.2   0.0096 0.0017  0.35

 Item statistics 
       n raw.r std.r r.cor r.drop mean  sd
C1  2779  0.65  0.67  0.54   0.45  4.5 1.2
C2  2776  0.70  0.71  0.60   0.50  4.4 1.3
C3  2780  0.66  0.67  0.54   0.46  4.3 1.3
C4- 2774  0.74  0.73  0.64   0.55  4.4 1.4
C5- 2784  0.72  0.68  0.57   0.48  3.7 1.6

Non missing response frequency for each item
      1    2    3    4    5    6 miss
C1 0.03 0.06 0.10 0.24 0.37 0.21 0.01
C2 0.03 0.09 0.11 0.23 0.35 0.20 0.01
C3 0.03 0.09 0.11 0.27 0.34 0.17 0.01
C4 0.28 0.29 0.17 0.16 0.08 0.02 0.01
C5 0.18 0.20 0.12 0.22 0.17 0.10 0.01

$extraversion

Reliability analysis   
Call: psych::alpha(x = select(pivot_wider(x, names_from = items, values_from = value), 
    matches("\\w\\d")), keys = str_remove(str_subset(bfi.keys[[bfi_key_name]], 
    pattern = "^-"), pattern = "^-"))

  raw_alpha std.alpha G6(smc) average_r S/N   ase mean  sd median_r
      0.76      0.76    0.73      0.39 3.2 0.007  4.1 1.1     0.38

    95% confidence boundaries 
         lower alpha upper
Feldt     0.75  0.76  0.78
Duhachek  0.75  0.76  0.78

 Reliability if an item is dropped:
    raw_alpha std.alpha G6(smc) average_r S/N alpha se  var.r med.r
E1-      0.73      0.73    0.67      0.40 2.6   0.0084 0.0044  0.38
E2-      0.69      0.69    0.63      0.36 2.3   0.0095 0.0028  0.35
E3       0.73      0.73    0.67      0.40 2.7   0.0082 0.0071  0.40
E4       0.70      0.70    0.65      0.37 2.4   0.0091 0.0033  0.38
E5       0.74      0.74    0.69      0.42 2.9   0.0078 0.0043  0.42

 Item statistics 
       n raw.r std.r r.cor r.drop mean  sd
E1- 2777  0.72  0.70  0.59   0.52  4.0 1.6
E2- 2784  0.78  0.76  0.69   0.61  3.9 1.6
E3  2775  0.68  0.70  0.58   0.50  4.0 1.4
E4  2791  0.75  0.75  0.66   0.58  4.4 1.5
E5  2779  0.64  0.66  0.52   0.45  4.4 1.3

Non missing response frequency for each item
      1    2    3    4    5    6 miss
E1 0.24 0.23 0.15 0.16 0.13 0.09 0.01
E2 0.19 0.24 0.12 0.22 0.14 0.09 0.01
E3 0.05 0.11 0.15 0.30 0.27 0.13 0.01
E4 0.05 0.09 0.10 0.16 0.34 0.26 0.00
E5 0.03 0.08 0.10 0.22 0.34 0.22 0.01

$neuroticism

Reliability analysis   
Call: psych::alpha(x = select(pivot_wider(x, names_from = items, values_from = value), 
    matches("\\w\\d")), keys = str_remove(str_subset(bfi.keys[[bfi_key_name]], 
    pattern = "^-"), pattern = "^-"))

  raw_alpha std.alpha G6(smc) average_r S/N    ase mean  sd median_r
      0.81      0.81     0.8      0.47 4.4 0.0056  3.2 1.2     0.41

    95% confidence boundaries 
         lower alpha upper
Feldt      0.8  0.81  0.82
Duhachek   0.8  0.81  0.82

 Reliability if an item is dropped:
   raw_alpha std.alpha G6(smc) average_r S/N alpha se  var.r med.r
N1      0.76      0.76    0.71      0.44 3.1   0.0075 0.0061  0.41
N2      0.76      0.76    0.72      0.45 3.2   0.0073 0.0054  0.41
N3      0.76      0.76    0.73      0.44 3.1   0.0077 0.0178  0.39
N4      0.80      0.80    0.77      0.49 3.9   0.0064 0.0181  0.49
N5      0.81      0.81    0.79      0.52 4.3   0.0059 0.0137  0.53

 Item statistics 
      n raw.r std.r r.cor r.drop mean  sd
N1 2778  0.80  0.80  0.76   0.67  2.9 1.6
N2 2779  0.79  0.79  0.75   0.65  3.5 1.5
N3 2789  0.81  0.81  0.74   0.67  3.2 1.6
N4 2764  0.72  0.71  0.60   0.54  3.2 1.6
N5 2771  0.68  0.67  0.53   0.49  3.0 1.6

Non missing response frequency for each item
      1    2    3    4    5    6 miss
N1 0.24 0.24 0.15 0.19 0.12 0.07 0.01
N2 0.12 0.19 0.15 0.26 0.18 0.10 0.01
N3 0.18 0.23 0.13 0.21 0.16 0.09 0.00
N4 0.17 0.24 0.15 0.22 0.14 0.09 0.01
N5 0.24 0.24 0.14 0.18 0.12 0.09 0.01

$openness

Reliability analysis   
Call: psych::alpha(x = select(pivot_wider(x, names_from = items, values_from = value), 
    matches("\\w\\d")), keys = str_remove(str_subset(bfi.keys[[bfi_key_name]], 
    pattern = "^-"), pattern = "^-"))

  raw_alpha std.alpha G6(smc) average_r S/N   ase mean   sd median_r
       0.6      0.61    0.57      0.24 1.5 0.012  4.6 0.81     0.23

    95% confidence boundaries 
         lower alpha upper
Feldt     0.58   0.6  0.62
Duhachek  0.58   0.6  0.62

 Reliability if an item is dropped:
    raw_alpha std.alpha G6(smc) average_r S/N alpha se  var.r med.r
O1       0.53      0.53    0.48      0.22 1.1    0.014 0.0092  0.23
O2-      0.57      0.57    0.51      0.25 1.3    0.013 0.0076  0.22
O3       0.50      0.50    0.44      0.20 1.0    0.015 0.0071  0.20
O4       0.61      0.62    0.56      0.29 1.6    0.012 0.0044  0.29
O5-      0.51      0.53    0.47      0.22 1.1    0.015 0.0116  0.20

 Item statistics 
       n raw.r std.r r.cor r.drop mean  sd
O1  2778  0.62  0.65  0.52   0.39  4.8 1.1
O2- 2800  0.65  0.60  0.43   0.33  4.3 1.6
O3  2772  0.67  0.69  0.59   0.45  4.4 1.2
O4  2786  0.50  0.52  0.29   0.22  4.9 1.2
O5- 2780  0.67  0.66  0.52   0.42  4.5 1.3

Non missing response frequency for each item
      1    2    3    4    5    6 miss
O1 0.01 0.04 0.08 0.22 0.33 0.33 0.01
O2 0.29 0.26 0.14 0.16 0.10 0.06 0.00
O3 0.03 0.05 0.11 0.28 0.34 0.20 0.01
O4 0.02 0.04 0.06 0.17 0.32 0.39 0.01
O5 0.27 0.32 0.19 0.13 0.07 0.03 0.01</code></pre>
</div>
</div>
<p>ということで、元のdfからmapを使って一気にα係数を求めることができました。一つのnamed listに下位尺度5つ分の出力が詰まっているので、オブジェクトに入れた際にGrobal Env.がオブジェクトだらけにならないというのはいい点かもしれないです。</p>
</section>
<section id="やりやすくなさそうなデータの場合" class="level2">
<h2 class="anchored" data-anchor-id="やりやすくなさそうなデータの場合">やりやすくなさそうなデータの場合</h2>
<p><code>bfi</code>データは列名に下位尺度の分類が含まれていたのでやりやすかったのですが、実際に扱うデータだとそうはいかない場合もあると思います。というわけで、<code>bfi</code>を少しいじってこんなデータを用意してみました。</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-1-contents" aria-controls="callout-1" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
改造の処理はこちら
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-1" class="callout-1-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p><code>bfi</code>の列をデモグラフィック列（26-28）以外ランダムに並べ替えるために、列番号をシャッフルします。</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1"></a><span class="fu">set.seed</span>(<span class="dv">20251025</span>)</span>
<span id="cb12-2"><a href="#cb12-2"></a></span>
<span id="cb12-3"><a href="#cb12-3"></a>(vec_col_order <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fu">sample</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">25</span>), <span class="dv">26</span><span class="sc">:</span><span class="dv">28</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code> [1] 23  7 13 25  1  3  5 10 17  8 21 22 15 16  4 19  6 18  9 20 12 11  2 14 24
[26] 26 27 28</code></pre>
</div>
</div>
<p>後でkeyを作る用のベクトルを作成。チェック用に元の<code>bfi</code>の列名を名前に付けておきます。</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1"></a>vec_names_df_test <span class="ot">&lt;-</span> <span class="fu">c</span>(</span>
<span id="cb14-2"><a href="#cb14-2"></a>  <span class="fu">paste0</span>(<span class="st">"q1_x"</span>, <span class="dv">1</span><span class="sc">:</span><span class="dv">25</span>),</span>
<span id="cb14-3"><a href="#cb14-3"></a>  <span class="fu">paste0</span>(<span class="st">"q2_x"</span>, <span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>)</span>
<span id="cb14-4"><a href="#cb14-4"></a>) <span class="sc">|&gt;</span></span>
<span id="cb14-5"><a href="#cb14-5"></a>  <span class="fu">setNames</span>(</span>
<span id="cb14-6"><a href="#cb14-6"></a>    <span class="fu">colnames</span>(bfi[, vec_col_order])</span>
<span id="cb14-7"><a href="#cb14-7"></a>  )</span>
<span id="cb14-8"><a href="#cb14-8"></a></span>
<span id="cb14-9"><a href="#cb14-9"></a>vec_names_df_test</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>       O3        C2        E3        O5        A1        A3        A5        C5 
  "q1_x1"   "q1_x2"   "q1_x3"   "q1_x4"   "q1_x5"   "q1_x6"   "q1_x7"   "q1_x8" 
       N2        C3        O1        O2        E5        N1        A4        N4 
  "q1_x9"  "q1_x10"  "q1_x11"  "q1_x12"  "q1_x13"  "q1_x14"  "q1_x15"  "q1_x16" 
       C1        N3        C4        N5        E2        E1        A2        E4 
 "q1_x17"  "q1_x18"  "q1_x19"  "q1_x20"  "q1_x21"  "q1_x22"  "q1_x23"  "q1_x24" 
       O4    gender education       age 
 "q1_x25"   "q2_x1"   "q2_x2"   "q2_x3" </code></pre>
</div>
</div>
<p>列番号をシャッフルしたベクトルを使って、列を並び替えたdfを作ります。ついでにid列もつけておきます。</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1"></a>df_test <span class="ot">&lt;-</span> bfi[, vec_col_order] <span class="sc">|&gt;</span></span>
<span id="cb16-2"><a href="#cb16-2"></a>  <span class="st">`</span><span class="at">colnames&lt;-</span><span class="st">`</span>(vec_names_df_test) <span class="sc">|&gt;</span></span>
<span id="cb16-3"><a href="#cb16-3"></a>  <span class="fu">rownames_to_column</span>(<span class="at">var =</span> <span class="st">"id"</span>)</span>
<span id="cb16-4"><a href="#cb16-4"></a></span>
<span id="cb16-5"><a href="#cb16-5"></a><span class="fu">colnames</span>(df_test)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code> [1] "id"     "q1_x1"  "q1_x2"  "q1_x3"  "q1_x4"  "q1_x5"  "q1_x6"  "q1_x7" 
 [9] "q1_x8"  "q1_x9"  "q1_x10" "q1_x11" "q1_x12" "q1_x13" "q1_x14" "q1_x15"
[17] "q1_x16" "q1_x17" "q1_x18" "q1_x19" "q1_x20" "q1_x21" "q1_x22" "q1_x23"
[25] "q1_x24" "q1_x25" "q2_x1"  "q2_x2"  "q2_x3" </code></pre>
</div>
</div>
<p>構成要素の分類を示すkeyを作ります。実際の場合はnamed listを自力で作成すればいいと思います（それか、<code>psych::make.keys()</code>あたりを使うか）。今回は手入力したくないのでゴリ押します。</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1"></a>list_test_keys <span class="ot">&lt;-</span></span>
<span id="cb18-2"><a href="#cb18-2"></a>  <span class="fu">names</span>(bfi.keys) <span class="sc">|&gt;</span></span>
<span id="cb18-3"><a href="#cb18-3"></a>  <span class="fu">str_extract</span>(<span class="at">pattern =</span> <span class="st">"^."</span>) <span class="sc">|&gt;</span></span>
<span id="cb18-4"><a href="#cb18-4"></a>  <span class="fu">toupper</span>() <span class="sc">|&gt;</span></span>
<span id="cb18-5"><a href="#cb18-5"></a>  <span class="fu">set_names</span>() <span class="sc">|&gt;</span></span>
<span id="cb18-6"><a href="#cb18-6"></a>  <span class="fu">map</span>(</span>
<span id="cb18-7"><a href="#cb18-7"></a>    <span class="at">.f =</span> \(x){</span>
<span id="cb18-8"><a href="#cb18-8"></a>      temp_vec <span class="ot">&lt;-</span> vec_names_df_test[<span class="dv">1</span><span class="sc">:</span><span class="dv">25</span>]</span>
<span id="cb18-9"><a href="#cb18-9"></a>      temp_vec[<span class="fu">str_starts</span>(<span class="fu">names</span>(temp_vec), x)]</span>
<span id="cb18-10"><a href="#cb18-10"></a>    }</span>
<span id="cb18-11"><a href="#cb18-11"></a>  ) <span class="sc">|&gt;</span></span>
<span id="cb18-12"><a href="#cb18-12"></a>  <span class="fu">map</span>(</span>
<span id="cb18-13"><a href="#cb18-13"></a>    <span class="at">.f =</span> \(x) {</span>
<span id="cb18-14"><a href="#cb18-14"></a>      <span class="fu">if_else</span>(</span>
<span id="cb18-15"><a href="#cb18-15"></a>        <span class="fu">names</span>(x) <span class="sc">%in%</span> <span class="fu">unlist</span>(bfi.keys),</span>
<span id="cb18-16"><a href="#cb18-16"></a>        x,</span>
<span id="cb18-17"><a href="#cb18-17"></a>        <span class="fu">paste0</span>(<span class="st">"-"</span>, x) <span class="sc">|&gt;</span></span>
<span id="cb18-18"><a href="#cb18-18"></a>          <span class="fu">set_names</span>(<span class="fu">names</span>(x))</span>
<span id="cb18-19"><a href="#cb18-19"></a>      )</span>
<span id="cb18-20"><a href="#cb18-20"></a>    }</span>
<span id="cb18-21"><a href="#cb18-21"></a>  )</span>
<span id="cb18-22"><a href="#cb18-22"></a></span>
<span id="cb18-23"><a href="#cb18-23"></a>list_test_keys</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>$A
      A1       A3       A5       A4       A2 
"-q1_x5"  "q1_x6"  "q1_x7" "q1_x15" "q1_x23" 

$C
       C2        C5        C3        C1        C4 
  "q1_x2"  "-q1_x8"  "q1_x10"  "q1_x17" "-q1_x19" 

$E
       E3        E5        E2        E1        E4 
  "q1_x3"  "q1_x13" "-q1_x21" "-q1_x22"  "q1_x24" 

$N
      N2       N1       N4       N3       N5 
 "q1_x9" "q1_x14" "q1_x16" "q1_x18" "q1_x20" 

$O
       O3        O5        O1        O2        O4 
  "q1_x1"  "-q1_x4"  "q1_x11" "-q1_x12"  "q1_x25" </code></pre>
</div>
</div>
<p>手入力の方がむしろ省コードだし楽だろ！！という指摘は今回はなかったことにします。</p>
<p>ちなみに逆転項目の設定はちゃんとできています。</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1"></a><span class="fu">data.frame</span>(</span>
<span id="cb20-2"><a href="#cb20-2"></a>  <span class="fu">enframe</span>(</span>
<span id="cb20-3"><a href="#cb20-3"></a>    <span class="fu">unlist</span>(list_test_keys)</span>
<span id="cb20-4"><a href="#cb20-4"></a>  ) <span class="sc">|&gt;</span></span>
<span id="cb20-5"><a href="#cb20-5"></a>    <span class="fu">arrange</span>(name),</span>
<span id="cb20-6"><a href="#cb20-6"></a>  <span class="fu">enframe</span>(</span>
<span id="cb20-7"><a href="#cb20-7"></a>    <span class="fu">unlist</span>(bfi.keys)</span>
<span id="cb20-8"><a href="#cb20-8"></a>  )</span>
<span id="cb20-9"><a href="#cb20-9"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>   name   value         name.1 value.1
1  A.A1  -q1_x5         agree1     -A1
2  A.A2  q1_x23         agree2      A2
3  A.A3   q1_x6         agree3      A3
4  A.A4  q1_x15         agree4      A4
5  A.A5   q1_x7         agree5      A5
6  C.C1  q1_x17 conscientious1      C1
7  C.C2   q1_x2 conscientious2      C2
8  C.C3  q1_x10 conscientious3      C3
9  C.C4 -q1_x19 conscientious4     -C4
10 C.C5  -q1_x8 conscientious5     -C5
11 E.E1 -q1_x22  extraversion1     -E1
12 E.E2 -q1_x21  extraversion2     -E2
13 E.E3   q1_x3  extraversion3      E3
14 E.E4  q1_x24  extraversion4      E4
15 E.E5  q1_x13  extraversion5      E5
16 N.N1  q1_x14   neuroticism1      N1
17 N.N2   q1_x9   neuroticism2      N2
18 N.N3  q1_x18   neuroticism3      N3
19 N.N4  q1_x16   neuroticism4      N4
20 N.N5  q1_x20   neuroticism5      N5
21 O.O1  q1_x11      openness1      O1
22 O.O2 -q1_x12      openness2     -O2
23 O.O3   q1_x1      openness3      O3
24 O.O4  q1_x25      openness4      O4
25 O.O5  -q1_x4      openness5     -O5</code></pre>
</div>
</div>
</div>
</div>
</div>
<p>元のデータと行数列数は一緒ですが、列名と順番が変わりました。コードブックの作成が必須ですね。</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1"></a><span class="fu">str</span>(df_test)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>'data.frame':   2800 obs. of  29 variables:
 $ id    : chr  "61617" "61618" "61620" "61621" ...
 $ q1_x1 : int  3 4 5 4 4 5 5 4 6 5 ...
 $ q1_x2 : int  3 4 5 4 4 6 4 2 6 5 ...
 $ q1_x3 : int  3 6 4 4 5 6 4 4 NA 4 ...
 $ q1_x4 : int  3 3 2 5 3 1 1 3 1 2 ...
 $ q1_x5 : int  2 2 5 4 2 6 2 4 4 2 ...
 $ q1_x6 : int  3 5 5 6 3 5 5 1 6 6 ...
 $ q1_x7 : int  4 5 4 5 5 5 5 1 3 5 ...
 $ q1_x8 : int  4 4 5 5 2 3 3 4 5 1 ...
 $ q1_x9 : int  4 3 5 5 3 5 2 3 5 5 ...
 $ q1_x10: int  3 4 4 3 5 6 4 4 3 6 ...
 $ q1_x11: int  3 4 4 3 3 4 5 3 6 5 ...
 $ q1_x12: int  6 2 2 3 3 3 2 2 6 1 ...
 $ q1_x13: int  4 3 5 4 5 6 5 1 3 5 ...
 $ q1_x14: int  3 3 4 2 2 3 1 6 5 5 ...
 $ q1_x15: int  4 2 4 5 4 6 3 5 3 6 ...
 $ q1_x16: int  2 5 2 4 4 2 1 6 3 2 ...
 $ q1_x17: int  2 5 4 4 4 6 5 3 6 6 ...
 $ q1_x18: int  2 3 4 2 4 2 2 2 2 5 ...
 $ q1_x19: int  4 3 2 5 3 1 2 2 4 2 ...
 $ q1_x20: int  3 5 3 1 3 3 1 4 3 4 ...
 $ q1_x21: int  3 1 4 3 2 1 3 6 3 2 ...
 $ q1_x22: int  3 1 2 5 2 2 4 3 5 2 ...
 $ q1_x23: int  4 4 4 4 3 6 5 3 3 5 ...
 $ q1_x24: int  4 4 4 4 4 5 5 2 4 5 ...
 $ q1_x25: int  4 3 5 3 3 6 6 5 6 5 ...
 $ q2_x1 : int  1 2 2 2 1 2 1 1 1 2 ...
 $ q2_x2 : int  NA NA NA NA NA 3 NA 2 1 NA ...
 $ q2_x3 : int  16 18 17 17 17 21 18 19 19 17 ...</code></pre>
</div>
</div>
<p>そして構成要素の分類のkeyも用意しました。要素のベクトルに名前がついているのはチェックのためで、本来はないと思ってください。QualtricsとかMicrosoft Formsとかには項目をランダムに提示する機能があるので、それを使えば列をこんなにシャッフルする必要はないんですが、「よくわからなかったので、尺度の項目の順番を自分で頑張ってシャッフルしちゃいました…」という事案はあると思います。</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1"></a>list_test_keys</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>$A
      A1       A3       A5       A4       A2 
"-q1_x5"  "q1_x6"  "q1_x7" "q1_x15" "q1_x23" 

$C
       C2        C5        C3        C1        C4 
  "q1_x2"  "-q1_x8"  "q1_x10"  "q1_x17" "-q1_x19" 

$E
       E3        E5        E2        E1        E4 
  "q1_x3"  "q1_x13" "-q1_x21" "-q1_x22"  "q1_x24" 

$N
      N2       N1       N4       N3       N5 
 "q1_x9" "q1_x14" "q1_x16" "q1_x18" "q1_x20" 

$O
       O3        O5        O1        O2        O4 
  "q1_x1"  "-q1_x4"  "q1_x11" "-q1_x12"  "q1_x25" </code></pre>
</div>
</div>
<p>というわけで、こちらのデータでも<code>map()</code>で<code>alpha()</code>を一気に処理してみようと思います。先ほどはデータセットの列名に下位尺度の分類が入っていたので処理が少なく済みましたが、今回はそうではないので処理が少し増えます。</p>
<p>まずlong型にした後、新たにマッチ用の列を作って逆転項目に-をつけます。（別にわざわざ新しい列を作らなくてもいいのですが、<code>alpha()</code>の出力のときに項目名の前後に-がつくのが気になるので、あえてマッチ用の列を作っています。）</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb26-1"><a href="#cb26-1"></a>df_test <span class="sc">|&gt;</span></span>
<span id="cb26-2"><a href="#cb26-2"></a>  <span class="fu">pivot_longer</span>(</span>
<span id="cb26-3"><a href="#cb26-3"></a>    <span class="at">cols =</span> <span class="fu">starts_with</span>(<span class="st">"q1"</span>),</span>
<span id="cb26-4"><a href="#cb26-4"></a>    <span class="at">names_to =</span> <span class="st">"items"</span></span>
<span id="cb26-5"><a href="#cb26-5"></a>  ) <span class="sc">|&gt;</span></span>
<span id="cb26-6"><a href="#cb26-6"></a>  <span class="fu">mutate</span>(</span>
<span id="cb26-7"><a href="#cb26-7"></a>    <span class="at">match_items =</span> <span class="fu">if_else</span>(</span>
<span id="cb26-8"><a href="#cb26-8"></a>      items <span class="sc">%in%</span> <span class="fu">unlist</span>(list_test_keys),</span>
<span id="cb26-9"><a href="#cb26-9"></a>      items,</span>
<span id="cb26-10"><a href="#cb26-10"></a>      <span class="fu">str_c</span>(<span class="st">"-"</span>, items)</span>
<span id="cb26-11"><a href="#cb26-11"></a>    )</span>
<span id="cb26-12"><a href="#cb26-12"></a>  )</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 70,000 × 7
   id    q2_x1 q2_x2 q2_x3 items  value match_items
   &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt;  &lt;int&gt; &lt;chr&gt;      
 1 61617     1    NA    16 q1_x1      3 q1_x1      
 2 61617     1    NA    16 q1_x2      3 q1_x2      
 3 61617     1    NA    16 q1_x3      3 q1_x3      
 4 61617     1    NA    16 q1_x4      3 -q1_x4     
 5 61617     1    NA    16 q1_x5      2 -q1_x5     
 6 61617     1    NA    16 q1_x6      3 q1_x6      
 7 61617     1    NA    16 q1_x7      4 q1_x7      
 8 61617     1    NA    16 q1_x8      4 -q1_x8     
 9 61617     1    NA    16 q1_x9      4 q1_x9      
10 61617     1    NA    16 q1_x10     3 q1_x10     
# ℹ 69,990 more rows</code></pre>
</div>
</div>
<p>次に、マッチ用の列を<code>dplyr::case_match()</code>に入れて、分類用のリストと照合します。<code>case_match()</code>は、第一引数<code>.x</code>にマッチさせたいベクトル、以降はtwo-sided formula形式で処理を書いていきます。左側（LHS）はマッチさせたい要素、右側（RHS）にはマッチしたものに対する出力を入れます。このformulaの部分だけは頑張って書かないといけません。今回は分類リストがnamed listでその要素は文字列ベクトルなので、各要素にマッチしたらその要素のリスト名（＝下位尺度の分類）を返すようにします。</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb28-1"><a href="#cb28-1"></a>df_test <span class="sc">|&gt;</span></span>
<span id="cb28-2"><a href="#cb28-2"></a>  <span class="fu">pivot_longer</span>(</span>
<span id="cb28-3"><a href="#cb28-3"></a>    <span class="at">cols =</span> <span class="fu">starts_with</span>(<span class="st">"q1"</span>),</span>
<span id="cb28-4"><a href="#cb28-4"></a>    <span class="at">names_to =</span> <span class="st">"items"</span></span>
<span id="cb28-5"><a href="#cb28-5"></a>  ) <span class="sc">|&gt;</span></span>
<span id="cb28-6"><a href="#cb28-6"></a>  <span class="fu">mutate</span>(</span>
<span id="cb28-7"><a href="#cb28-7"></a>    <span class="at">match_items =</span> <span class="fu">if_else</span>(</span>
<span id="cb28-8"><a href="#cb28-8"></a>      items <span class="sc">%in%</span> <span class="fu">unlist</span>(list_test_keys),</span>
<span id="cb28-9"><a href="#cb28-9"></a>      items,</span>
<span id="cb28-10"><a href="#cb28-10"></a>      <span class="fu">str_c</span>(<span class="st">"-"</span>, items)</span>
<span id="cb28-11"><a href="#cb28-11"></a>    ),</span>
<span id="cb28-12"><a href="#cb28-12"></a>    <span class="at">nest_key =</span> <span class="fu">case_match</span>(</span>
<span id="cb28-13"><a href="#cb28-13"></a>      match_items,</span>
<span id="cb28-14"><a href="#cb28-14"></a>      list_test_keys[[<span class="st">"A"</span>]] <span class="sc">~</span> <span class="st">"A"</span>,</span>
<span id="cb28-15"><a href="#cb28-15"></a>      list_test_keys[[<span class="st">"C"</span>]] <span class="sc">~</span> <span class="st">"C"</span>,</span>
<span id="cb28-16"><a href="#cb28-16"></a>      list_test_keys[[<span class="st">"E"</span>]] <span class="sc">~</span> <span class="st">"E"</span>,</span>
<span id="cb28-17"><a href="#cb28-17"></a>      list_test_keys[[<span class="st">"N"</span>]] <span class="sc">~</span> <span class="st">"N"</span>,</span>
<span id="cb28-18"><a href="#cb28-18"></a>      list_test_keys[[<span class="st">"O"</span>]] <span class="sc">~</span> <span class="st">"O"</span>,</span>
<span id="cb28-19"><a href="#cb28-19"></a>    )</span>
<span id="cb28-20"><a href="#cb28-20"></a>  )</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 70,000 × 8
   id    q2_x1 q2_x2 q2_x3 items  value match_items nest_key
   &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt;  &lt;int&gt; &lt;chr&gt;       &lt;chr&gt;   
 1 61617     1    NA    16 q1_x1      3 q1_x1       O       
 2 61617     1    NA    16 q1_x2      3 q1_x2       C       
 3 61617     1    NA    16 q1_x3      3 q1_x3       E       
 4 61617     1    NA    16 q1_x4      3 -q1_x4      O       
 5 61617     1    NA    16 q1_x5      2 -q1_x5      A       
 6 61617     1    NA    16 q1_x6      3 q1_x6       A       
 7 61617     1    NA    16 q1_x7      4 q1_x7       A       
 8 61617     1    NA    16 q1_x8      4 -q1_x8      C       
 9 61617     1    NA    16 q1_x9      4 q1_x9       N       
10 61617     1    NA    16 q1_x10     3 q1_x10      C       
# ℹ 69,990 more rows</code></pre>
</div>
</div>
<p>後の処理は先ほどと変わりません。nestしたうえでmap処理をしていけばいいです。</p>
<div class="cell">
<div class="sourceCode cell-code" id="annotated-cell-14"><pre class="sourceCode numberSource r code-annotation-code number-lines code-with-copy code-annotated"><code class="sourceCode r"><span id="annotated-cell-14-1"><a href="#annotated-cell-14-1"></a>df_test <span class="sc">|&gt;</span></span>
<span id="annotated-cell-14-2"><a href="#annotated-cell-14-2"></a>  <span class="fu">pivot_longer</span>(</span>
<span id="annotated-cell-14-3"><a href="#annotated-cell-14-3"></a>    <span class="at">cols =</span> <span class="fu">starts_with</span>(<span class="st">"q1"</span>),</span>
<span id="annotated-cell-14-4"><a href="#annotated-cell-14-4"></a>    <span class="at">names_to =</span> <span class="st">"items"</span></span>
<span id="annotated-cell-14-5"><a href="#annotated-cell-14-5"></a>  ) <span class="sc">|&gt;</span></span>
<span id="annotated-cell-14-6"><a href="#annotated-cell-14-6"></a>  <span class="fu">mutate</span>(</span>
<span id="annotated-cell-14-7"><a href="#annotated-cell-14-7"></a>    <span class="at">match_items =</span> <span class="fu">if_else</span>(</span>
<span id="annotated-cell-14-8"><a href="#annotated-cell-14-8"></a>      items <span class="sc">%in%</span> <span class="fu">unlist</span>(list_test_keys),</span>
<span id="annotated-cell-14-9"><a href="#annotated-cell-14-9"></a>      items,</span>
<span id="annotated-cell-14-10"><a href="#annotated-cell-14-10"></a>      <span class="fu">str_c</span>(<span class="st">"-"</span>, items)</span>
<span id="annotated-cell-14-11"><a href="#annotated-cell-14-11"></a>    ),</span>
<span id="annotated-cell-14-12"><a href="#annotated-cell-14-12"></a>    <span class="at">nest_key =</span> <span class="fu">case_match</span>(</span>
<span id="annotated-cell-14-13"><a href="#annotated-cell-14-13"></a>      match_items,</span>
<span id="annotated-cell-14-14"><a href="#annotated-cell-14-14"></a>      list_test_keys[[<span class="st">"A"</span>]] <span class="sc">~</span> <span class="st">"A"</span>,</span>
<span id="annotated-cell-14-15"><a href="#annotated-cell-14-15"></a>      list_test_keys[[<span class="st">"C"</span>]] <span class="sc">~</span> <span class="st">"C"</span>,</span>
<span id="annotated-cell-14-16"><a href="#annotated-cell-14-16"></a>      list_test_keys[[<span class="st">"E"</span>]] <span class="sc">~</span> <span class="st">"E"</span>,</span>
<span id="annotated-cell-14-17"><a href="#annotated-cell-14-17"></a>      list_test_keys[[<span class="st">"N"</span>]] <span class="sc">~</span> <span class="st">"N"</span>,</span>
<span id="annotated-cell-14-18"><a href="#annotated-cell-14-18"></a>      list_test_keys[[<span class="st">"O"</span>]] <span class="sc">~</span> <span class="st">"O"</span></span>
<span id="annotated-cell-14-19"><a href="#annotated-cell-14-19"></a>    )</span>
<span id="annotated-cell-14-20"><a href="#annotated-cell-14-20"></a>  ) <span class="sc">|&gt;</span></span>
<span id="annotated-cell-14-21"><a href="#annotated-cell-14-21"></a>  <span class="fu">nest</span>(<span class="at">.by =</span> nest_key) <span class="sc">|&gt;</span></span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-14" data-target-annotation="1" onclick="event.preventDefault();">1</a><span id="annotated-cell-14-22" class="code-annotation-target"><a href="#annotated-cell-14-22"></a>  <span class="fu">arrange</span>(nest_key) <span class="sc">|&gt;</span></span>
<span id="annotated-cell-14-23"><a href="#annotated-cell-14-23"></a>  <span class="fu">mutate</span>(</span>
<span id="annotated-cell-14-24"><a href="#annotated-cell-14-24"></a>    <span class="at">res_alpha =</span> <span class="fu">map</span>(</span>
<span id="annotated-cell-14-25"><a href="#annotated-cell-14-25"></a>      <span class="at">.x =</span> data,</span>
<span id="annotated-cell-14-26"><a href="#annotated-cell-14-26"></a>      <span class="at">.f =</span> \(x) {</span>
<span id="annotated-cell-14-27"><a href="#annotated-cell-14-27"></a>        x <span class="sc">|&gt;</span></span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-14" data-target-annotation="2" onclick="event.preventDefault();">2</a><span id="annotated-cell-14-28" class="code-annotation-target"><a href="#annotated-cell-14-28"></a>          <span class="fu">select</span>(<span class="sc">-</span>match_items) <span class="sc">|&gt;</span></span>
<span id="annotated-cell-14-29"><a href="#annotated-cell-14-29"></a>          <span class="fu">pivot_wider</span>(</span>
<span id="annotated-cell-14-30"><a href="#annotated-cell-14-30"></a>            <span class="at">names_from =</span> items,</span>
<span id="annotated-cell-14-31"><a href="#annotated-cell-14-31"></a>            <span class="at">values_from =</span> value</span>
<span id="annotated-cell-14-32"><a href="#annotated-cell-14-32"></a>          ) <span class="sc">|&gt;</span></span>
<span id="annotated-cell-14-33"><a href="#annotated-cell-14-33"></a>          <span class="fu">select</span>(<span class="fu">starts_with</span>(<span class="st">"q1"</span>)) <span class="sc">|&gt;</span></span>
<span id="annotated-cell-14-34"><a href="#annotated-cell-14-34"></a>          psych<span class="sc">::</span><span class="fu">alpha</span>(</span>
<span id="annotated-cell-14-35"><a href="#annotated-cell-14-35"></a>            <span class="at">keys =</span> list_test_keys[[nest_key]] <span class="sc">|&gt;</span></span>
<span id="annotated-cell-14-36"><a href="#annotated-cell-14-36"></a>              <span class="fu">str_subset</span>(<span class="st">"^-"</span>) <span class="sc">|&gt;</span></span>
<span id="annotated-cell-14-37"><a href="#annotated-cell-14-37"></a>              <span class="fu">str_remove</span>(<span class="st">"^-"</span>)</span>
<span id="annotated-cell-14-38"><a href="#annotated-cell-14-38"></a>          )</span>
<span id="annotated-cell-14-39"><a href="#annotated-cell-14-39"></a>      }</span>
<span id="annotated-cell-14-40"><a href="#annotated-cell-14-40"></a>    ) <span class="sc">|&gt;</span></span>
<span id="annotated-cell-14-41"><a href="#annotated-cell-14-41"></a>      <span class="fu">set_names</span>(nest_key),</span>
<span id="annotated-cell-14-42"><a href="#annotated-cell-14-42"></a>    <span class="at">.by =</span> nest_key</span>
<span id="annotated-cell-14-43"><a href="#annotated-cell-14-43"></a>  ) <span class="sc">|&gt;</span></span>
<span id="annotated-cell-14-44"><a href="#annotated-cell-14-44"></a>  <span class="fu">pull</span>(res_alpha)</span><div class="code-annotation-gutter-bg"></div><div class="code-annotation-gutter"></div></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-annotation">
<dl class="code-annotation-container-grid">
<dt data-target-cell="annotated-cell-14" data-target-annotation="1">1</dt>
<dd>
<span data-code-cell="annotated-cell-14" data-code-lines="22" data-code-annotation="1">dplyrとかで実装されている引数<code>.by</code>はデータを出現順に並べるので、データによっては出力がきれいな順番（A, B, C, … ）にならないです。なので見やすくするために<code>dplyr::arrange()</code>でソートしておきます。</span>
</dd>
<dt data-target-cell="annotated-cell-14" data-target-annotation="2">2</dt>
<dd>
<span data-code-cell="annotated-cell-14" data-code-lines="28" data-code-annotation="2">マッチ用の列は残しておくとwide型にしたときにデータがズレるので外しておきます。マッチ用の列を作っていなかったら省略してOKです。</span>
</dd>
</dl>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>$A

Reliability analysis   
Call: psych::alpha(x = select(pivot_wider(select(x, -match_items), 
    names_from = items, values_from = value), starts_with("q1")), 
    keys = str_remove(str_subset(list_test_keys[[nest_key]], 
        "^-"), "^-"))

  raw_alpha std.alpha G6(smc) average_r S/N   ase mean  sd median_r
       0.7      0.71    0.68      0.33 2.5 0.009  4.7 0.9     0.34

    95% confidence boundaries 
         lower alpha upper
Feldt     0.69   0.7  0.72
Duhachek  0.69   0.7  0.72

 Reliability if an item is dropped:
       raw_alpha std.alpha G6(smc) average_r S/N alpha se  var.r med.r
q1_x5-      0.72      0.72    0.67      0.40 2.6   0.0087 0.0065  0.38
q1_x6       0.60      0.61    0.56      0.28 1.6   0.0124 0.0094  0.32
q1_x7       0.64      0.66    0.60      0.32 1.9   0.0111 0.0125  0.34
q1_x15      0.69      0.69    0.65      0.36 2.3   0.0098 0.0157  0.37
q1_x23      0.62      0.63    0.58      0.29 1.7   0.0119 0.0168  0.29

 Item statistics 
          n raw.r std.r r.cor r.drop mean  sd
q1_x5- 2784  0.58  0.57  0.38   0.31  4.6 1.4
q1_x6  2774  0.76  0.77  0.71   0.59  4.6 1.3
q1_x7  2784  0.69  0.70  0.59   0.49  4.6 1.3
q1_x15 2781  0.65  0.63  0.47   0.39  4.7 1.5
q1_x23 2773  0.73  0.75  0.67   0.56  4.8 1.2

Non missing response frequency for each item
          1    2    3    4    5    6 miss
q1_x5  0.33 0.29 0.14 0.12 0.08 0.03 0.01
q1_x6  0.03 0.06 0.07 0.20 0.36 0.27 0.01
q1_x7  0.02 0.07 0.09 0.22 0.35 0.25 0.01
q1_x15 0.05 0.08 0.07 0.16 0.24 0.41 0.01
q1_x23 0.02 0.05 0.05 0.20 0.37 0.31 0.01

$C

Reliability analysis   
Call: psych::alpha(x = select(pivot_wider(select(x, -match_items), 
    names_from = items, values_from = value), starts_with("q1")), 
    keys = str_remove(str_subset(list_test_keys[[nest_key]], 
        "^-"), "^-"))

  raw_alpha std.alpha G6(smc) average_r S/N    ase mean   sd median_r
      0.73      0.73    0.69      0.35 2.7 0.0081  4.3 0.95     0.34

    95% confidence boundaries 
         lower alpha upper
Feldt     0.71  0.73  0.74
Duhachek  0.71  0.73  0.74

 Reliability if an item is dropped:
        raw_alpha std.alpha G6(smc) average_r S/N alpha se  var.r med.r
q1_x2        0.67      0.68    0.62      0.34 2.1   0.0099 0.0056  0.34
q1_x8-       0.69      0.69    0.63      0.36 2.2   0.0096 0.0017  0.35
q1_x10       0.69      0.69    0.64      0.36 2.3   0.0096 0.0070  0.36
q1_x17       0.69      0.70    0.64      0.36 2.3   0.0093 0.0037  0.35
q1_x19-      0.65      0.66    0.60      0.33 2.0   0.0107 0.0037  0.32

 Item statistics 
           n raw.r std.r r.cor r.drop mean  sd
q1_x2   2776  0.70  0.71  0.60   0.50  4.4 1.3
q1_x8-  2784  0.72  0.68  0.57   0.48  3.7 1.6
q1_x10  2780  0.66  0.67  0.54   0.46  4.3 1.3
q1_x17  2779  0.65  0.67  0.54   0.45  4.5 1.2
q1_x19- 2774  0.74  0.73  0.64   0.55  4.4 1.4

Non missing response frequency for each item
          1    2    3    4    5    6 miss
q1_x2  0.03 0.09 0.11 0.23 0.35 0.20 0.01
q1_x8  0.18 0.20 0.12 0.22 0.17 0.10 0.01
q1_x10 0.03 0.09 0.11 0.27 0.34 0.17 0.01
q1_x17 0.03 0.06 0.10 0.24 0.37 0.21 0.01
q1_x19 0.28 0.29 0.17 0.16 0.08 0.02 0.01

$E

Reliability analysis   
Call: psych::alpha(x = select(pivot_wider(select(x, -match_items), 
    names_from = items, values_from = value), starts_with("q1")), 
    keys = str_remove(str_subset(list_test_keys[[nest_key]], 
        "^-"), "^-"))

  raw_alpha std.alpha G6(smc) average_r S/N   ase mean  sd median_r
      0.76      0.76    0.73      0.39 3.2 0.007  4.1 1.1     0.38

    95% confidence boundaries 
         lower alpha upper
Feldt     0.75  0.76  0.78
Duhachek  0.75  0.76  0.78

 Reliability if an item is dropped:
        raw_alpha std.alpha G6(smc) average_r S/N alpha se  var.r med.r
q1_x3        0.73      0.73    0.67      0.40 2.7   0.0082 0.0071  0.40
q1_x13       0.74      0.74    0.69      0.42 2.9   0.0078 0.0043  0.42
q1_x21-      0.69      0.69    0.63      0.36 2.3   0.0095 0.0028  0.35
q1_x22-      0.73      0.73    0.67      0.40 2.6   0.0084 0.0044  0.38
q1_x24       0.70      0.70    0.65      0.37 2.4   0.0091 0.0033  0.38

 Item statistics 
           n raw.r std.r r.cor r.drop mean  sd
q1_x3   2775  0.68  0.70  0.58   0.50  4.0 1.4
q1_x13  2779  0.64  0.66  0.52   0.45  4.4 1.3
q1_x21- 2784  0.78  0.76  0.69   0.61  3.9 1.6
q1_x22- 2777  0.72  0.70  0.59   0.52  4.0 1.6
q1_x24  2791  0.75  0.75  0.66   0.58  4.4 1.5

Non missing response frequency for each item
          1    2    3    4    5    6 miss
q1_x3  0.05 0.11 0.15 0.30 0.27 0.13 0.01
q1_x13 0.03 0.08 0.10 0.22 0.34 0.22 0.01
q1_x21 0.19 0.24 0.12 0.22 0.14 0.09 0.01
q1_x22 0.24 0.23 0.15 0.16 0.13 0.09 0.01
q1_x24 0.05 0.09 0.10 0.16 0.34 0.26 0.00

$N

Reliability analysis   
Call: psych::alpha(x = select(pivot_wider(select(x, -match_items), 
    names_from = items, values_from = value), starts_with("q1")), 
    keys = str_remove(str_subset(list_test_keys[[nest_key]], 
        "^-"), "^-"))

  raw_alpha std.alpha G6(smc) average_r S/N    ase mean  sd median_r
      0.81      0.81     0.8      0.47 4.4 0.0056  3.2 1.2     0.41

    95% confidence boundaries 
         lower alpha upper
Feldt      0.8  0.81  0.82
Duhachek   0.8  0.81  0.82

 Reliability if an item is dropped:
       raw_alpha std.alpha G6(smc) average_r S/N alpha se  var.r med.r
q1_x9       0.76      0.76    0.72      0.45 3.2   0.0073 0.0054  0.41
q1_x14      0.76      0.76    0.71      0.44 3.1   0.0075 0.0061  0.41
q1_x16      0.80      0.80    0.77      0.49 3.9   0.0064 0.0181  0.49
q1_x18      0.76      0.76    0.73      0.44 3.1   0.0077 0.0178  0.39
q1_x20      0.81      0.81    0.79      0.52 4.3   0.0059 0.0137  0.53

 Item statistics 
          n raw.r std.r r.cor r.drop mean  sd
q1_x9  2779  0.79  0.79  0.75   0.65  3.5 1.5
q1_x14 2778  0.80  0.80  0.76   0.67  2.9 1.6
q1_x16 2764  0.72  0.71  0.60   0.54  3.2 1.6
q1_x18 2789  0.81  0.81  0.74   0.67  3.2 1.6
q1_x20 2771  0.68  0.67  0.53   0.49  3.0 1.6

Non missing response frequency for each item
          1    2    3    4    5    6 miss
q1_x9  0.12 0.19 0.15 0.26 0.18 0.10 0.01
q1_x14 0.24 0.24 0.15 0.19 0.12 0.07 0.01
q1_x16 0.17 0.24 0.15 0.22 0.14 0.09 0.01
q1_x18 0.18 0.23 0.13 0.21 0.16 0.09 0.00
q1_x20 0.24 0.24 0.14 0.18 0.12 0.09 0.01

$O

Reliability analysis   
Call: psych::alpha(x = select(pivot_wider(select(x, -match_items), 
    names_from = items, values_from = value), starts_with("q1")), 
    keys = str_remove(str_subset(list_test_keys[[nest_key]], 
        "^-"), "^-"))

  raw_alpha std.alpha G6(smc) average_r S/N   ase mean   sd median_r
       0.6      0.61    0.57      0.24 1.5 0.012  4.6 0.81     0.23

    95% confidence boundaries 
         lower alpha upper
Feldt     0.58   0.6  0.62
Duhachek  0.58   0.6  0.62

 Reliability if an item is dropped:
        raw_alpha std.alpha G6(smc) average_r S/N alpha se  var.r med.r
q1_x1        0.50      0.50    0.44      0.20 1.0    0.015 0.0071  0.20
q1_x4-       0.51      0.53    0.47      0.22 1.1    0.015 0.0116  0.20
q1_x11       0.53      0.53    0.48      0.22 1.1    0.014 0.0092  0.23
q1_x12-      0.57      0.57    0.51      0.25 1.3    0.013 0.0076  0.22
q1_x25       0.61      0.62    0.56      0.29 1.6    0.012 0.0044  0.29

 Item statistics 
           n raw.r std.r r.cor r.drop mean  sd
q1_x1   2772  0.67  0.69  0.59   0.45  4.4 1.2
q1_x4-  2780  0.67  0.66  0.52   0.42  4.5 1.3
q1_x11  2778  0.62  0.65  0.52   0.39  4.8 1.1
q1_x12- 2800  0.65  0.60  0.43   0.33  4.3 1.6
q1_x25  2786  0.50  0.52  0.29   0.22  4.9 1.2

Non missing response frequency for each item
          1    2    3    4    5    6 miss
q1_x1  0.03 0.05 0.11 0.28 0.34 0.20 0.01
q1_x4  0.27 0.32 0.19 0.13 0.07 0.03 0.01
q1_x11 0.01 0.04 0.08 0.22 0.33 0.33 0.01
q1_x12 0.29 0.26 0.14 0.16 0.10 0.06 0.00
q1_x25 0.02 0.04 0.06 0.17 0.32 0.39 0.01</code></pre>
</div>
</div>
<p>こちらのデータでもうまくできました。</p>
</section>
</section>
<section id="conclusion" class="level1">
<h1>Conclusion</h1>
<p>というわけで、<code>purrr::map()</code>の中で<code>psych::alpha()</code>を使って、元のdfから一気にα係数の処理をしてみました。コードの可読性という観点からみると下位尺度ごとに処理をしてオブジェクトに入れていく方法の方が見てわかりやすいし、コードの量もそれほど多くならないので、map処理で一気にやる方法が実用的かはわかりません。ただ、パイプフローの中でシーケンシャルに進められる点やミスの原因となる要素の手入力を減らせる点が個人的にはいいと思います。</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
            // target, if specified
            link.setAttribute("target", "_blank");
            if (link.getAttribute("rel") === null) {
              link.setAttribute("rel", "noopener");
            }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>Copyright 2025 Takuto Sakai<br> Content on this website is licensed under <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.en">CC BY-SA 4.0</a>.<br> Code is released under the <a href="../../LICENSE.html">MIT License</a>.</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
<p>Please contact me via <a href="https://x.com/tsakai_psych">X (Twitter)</a>.</p>
</div>
  </div>
</footer>




</body></html>