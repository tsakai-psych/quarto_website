{
  "hash": "441e530d979c5c3b1d54b7ce4c8b1931",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"R ネイティブパイプ（|>）の右辺で算術演算子とか関係演算子を使う方法\"\nsubtitle: \"How to Use Arithmetic and Relational Operators on the RHS of R’s Native Pipe (|>)\"\ndate: 2026-02-14\nabstract: |\n    ネイティブパイプ（|>）の右辺でも算術演算子とか関係演算子は使える。ただし、要件あり。\ncategories: [R memo, Base R, R syntax, pipes]\nformat:\n  html:\n    toc-depth: 4\nknitr:\n  opts_chunk: \n    fig.align: center\n    dev: ragg_png\n    R.options:\n      width: 100\neditor_options: \n  chunk_output_type: console\n---\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](index_files/figure-html/thmubnail-1.png){fig-align='center' width=75%}\n:::\n:::\n\n\n## Packages\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(magrittr)\n```\n:::\n\n\n## Contents\n### Problem\nR 4.1以降で使えるようになった組み込みのパイプ演算子`|>`。ネイティブパイプと呼ばれているこのパイプ演算子ですが、tidyverseでおなじみの`magrittr`パイプ演算子（`%>%`）より機能が制限されていることは有名です。詳しくは`help(\"|>\")`やHadley氏の解説記事[^tidyverse_blog]を見てください。\n\n[^tidyverse_blog]: <https://tidyverse.org/blog/2023/04/base-vs-magrittr-pipe/>\n\n制限されていることの一つとして、`help(\"|>\")`だとこう書いてあります。\n\n> To avoid ambiguities, functions in rhs calls may not be syntactically special, such as + or if.\n\nネイティブパイプの右辺では`+`や`if`のような関数が特別扱いを受けません。つまりこういうことです。\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n1:3 |> _ + 2\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in \"_\": The pipe operator requires a function call as RHS (<input>:1:8)\n```\n\n\n:::\n:::\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n1:3 |> `+`(2)\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in +2: function '+' not supported in RHS call of a pipe (<input>:1:8)\n```\n\n\n:::\n:::\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n2:6 |> `<`(4)\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in <4: function '<' not supported in RHS call of a pipe (<input>:1:8)\n```\n\n\n:::\n:::\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nc(TRUE, FALSE, NA, TRUE, FALSE, TRUE) |> `!`()\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in !NULL: function '!' not supported in RHS call of a pipe (<input>:1:42)\n```\n\n\n:::\n:::\n\n算術演算子（`+`, `-`, `%%`, etc...）や関係演算子（`<`, `!=`,  etc...）、NOT（`!`）などがすんなり使えません。こういう演算子はバッククォートで囲むと大体OKだったりするのですが、パイプフローだとそうはいかないようです。\n\nちなみにmagrittrパイプだとできます。\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n1:3 %>% + 2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3 4 5\n```\n\n\n:::\n\n```{.r .cell-code}\n1:3 %>% `+`(2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3 4 5\n```\n\n\n:::\n\n```{.r .cell-code}\n2:6 %>% `<`(4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE  TRUE FALSE FALSE FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nc(TRUE, FALSE, NA, TRUE, FALSE, TRUE) %>% `!`()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE  TRUE    NA FALSE  TRUE FALSE\n```\n\n\n:::\n:::\n\n\nそういう演算子使うときはパイプ使って書かなくていいじゃんとか、magrittrパイプ使えばいいじゃんとか思うかもしれません。ですが、パッケージの読み込みなしでそのまま使えたり、最近はmagrittr側が高速化しているとはいえネイティブパイプの方が速かったり[^r_native_pipe]と、ネイティブパイプ使用にもメリットはあります。特にモンテカルロシミュレーションを時々やる身としては、少しでも速い方がいいのです。あと私はネイティブパイプerなので、途中でmagrittrパイプが混じるのは個人的にはなんかちょっと統一性がなくてあまり好みではありません。あと、R for Data Science 2nd ed.ではネイティブパイプの使用を推奨していますし[^r4ds]。\n\n[^r_native_pipe]: 例えば<https://speakerdeck.com/s_uryu/r-native-pipe?slide=12>とか、<https://t-arae.blog/posts/2024/2024-07-27-r-pipe2/>とか。自分でも時々ベンチを回したりします。\n[^r4ds]: <https://r4ds.hadley.nz/data-transform.html#sec-the-pipe>\n\nというわけで前からちょくちょく調べたり考えたりしてました。↓\n\n<blockquote class=\"twitter-tweet\" data-theme=\"dark\"><p lang=\"ja\" dir=\"ltr\">Rの備忘録<br>native pipe のpipelineでの論理値の反転が、|&gt; (`!`) () という記法で通るらしい<br>どういうことなのかよくわからない<a href=\"https://t.co/RlqVIhuqnJ\">https://t.co/RlqVIhuqnJ</a> <a href=\"https://t.co/BCpjYWhsns\">pic.twitter.com/BCpjYWhsns</a></p>&mdash; Takuto SAKAI (@tsakai_psych) <a href=\"https://twitter.com/tsakai_psych/status/2005922436051595486?ref_src=twsrc%5Etfw\">December 30, 2025</a></blockquote> <script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n\n個人的には、無名関数も`()`によるラップも、()や\\{\\}が増えて何となく可読性が下がるような気がしてもやもやしています。（と言いつつ、普段は無名関数をバンバン使っています。）\n\n### Solution\nそれで、このあいだ`help(\"groupGeneric\")`とにらめっこしていろいろ試していたら、なんか通る書き方がありました。\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n1:3 |> `+`(e1 = _, e2 = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3 4 5\n```\n\n\n:::\n\n```{.r .cell-code}\n2:6 |> `<`(e1 = _, e2 = 4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE  TRUE FALSE FALSE FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nc(TRUE, FALSE, NA, TRUE, FALSE, TRUE) |>\n  `!`(e1 = _)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE  TRUE    NA FALSE  TRUE FALSE\n```\n\n\n:::\n:::\n\nどうやら第一引数名＋プレースホルダー（`e1 = _`）で通るようです。ネイティブパイプでは第一引数以外に値を渡したいときに引数名が必要だというルールがあるのですが、これらの特別な演算子だとどうやら異なるようです。\n\nとりあえず、Opsグループの演算子のすべてで試します。\n\n#### Arithmetic operators\n\n- 足し算\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n1:3 |> `+`(e1 = _, e2 = 2) # 3, 4, 5\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3 4 5\n```\n\n\n:::\n:::\n\n\n- 引き算\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n1:3 |> `-`(e1 = _, e2 = 2) # -1, 0, 1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -1  0  1\n```\n\n\n:::\n:::\n\n\n- 掛け算\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n1:3 |> `*`(e1 = _, e2 = 3) # 3, 6, 9\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3 6 9\n```\n\n\n:::\n:::\n\n\n- 割り算\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n1:3 |> `/`(e1 = _, e2 = 2) # 0.5, 1, 1.5\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.5 1.0 1.5\n```\n\n\n:::\n:::\n\n\n- 累乗\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n1:3 |> `^`(e1 = _, e2 = 4) # 1, 16, 81\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  1 16 81\n```\n\n\n:::\n:::\n\n\n- Mod計算\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n10:13 |> `%%`(e1 = _, e2 = 3) # 1, 2, 0, 1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 0 1\n```\n\n\n:::\n:::\n\n\n- 商の計算\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n10:13 |> `%/%`(e1 = _, e2 = 2) # 5, 5, 6, 6\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5 5 6 6\n```\n\n\n:::\n:::\n\n\n#### Logical operators\n\n- AND\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nc(TRUE, FALSE, NA, TRUE, TRUE, FALSE) |>\n  `&`(e1 = _, e2 = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE FALSE    NA  TRUE  TRUE FALSE\n```\n\n\n:::\n:::\n\n\n- OR\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nc(TRUE, FALSE, NA, TRUE, TRUE, FALSE) |>\n  `|`(e1 = _, e2 = FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE FALSE    NA  TRUE  TRUE FALSE\n```\n\n\n:::\n:::\n\n\n- NOT\n  - なお`!`は単項演算子（unary operator）なので、第一引数`x`に対してプレースホルダーを置くだけでいいです。引数名が`x`なのは後述します。\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nc(TRUE, FALSE, NA, TRUE, TRUE, FALSE) |>\n  `!`(x = _)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE  TRUE    NA FALSE FALSE  TRUE\n```\n\n\n:::\n:::\n\n\n#### Relational (comparison) operators\n\n- equal\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nc(\"hoge\", \"huga\", \"piyo\") |>\n  `==`(e1 = _, e2 = \"huga\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE  TRUE FALSE\n```\n\n\n:::\n:::\n\n\n- not equal\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nc(\"hoge\", \"huga\", \"piyo\") |>\n  `!=`(e1 = _, e2 = \"huga\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE FALSE  TRUE\n```\n\n\n:::\n:::\n\n\n- less\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n1:3 |>\n  `<`(e1 = _, e2 = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE FALSE FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\n1:3 |>\n  `<=`(e1 = _, e2 = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE  TRUE FALSE\n```\n\n\n:::\n:::\n\n\n- greater\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n1:3 |>\n  `>`(e1 = _, e2 = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE FALSE  TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\n1:3 |>\n  `>=`(e1 = _, e2 = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE  TRUE  TRUE\n```\n\n\n:::\n:::\n\n\n#### Matrix products\n\n- 行列の掛け算\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n(mat_1 <- matrix(\n  1:4,\n  nrow = 2\n))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n```\n\n\n:::\n\n```{.r .cell-code}\n(mat_2 <- matrix(\n  1:6,\n  nrow = 2\n))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n```\n\n\n:::\n\n```{.r .cell-code}\nmat_1 |> `%*%`(e1 = _, e2 = mat_2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    7   15   23\n[2,]   10   22   34\n```\n\n\n:::\n:::\n\n\n#### Arguments name\n二項演算子の引数名については、`help(\"groupGeneric\")`に倣い、また、演算子を呼び出してみると以下のように出力されるのもあって、`(e1 = _, e2 = y)`の書き方をしました。\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n`+`\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nfunction (e1, e2)  .Primitive(\"+\")\n```\n\n\n:::\n\n```{.r .cell-code}\n`%%`\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nfunction (e1, e2)  .Primitive(\"%%\")\n```\n\n\n:::\n:::\n\n\nですが、どうやら引数名は何でもよいみたいですし、プレースホルダー側でなければ引数名がなくても通るようです。\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n1:3 |> `+`(x = _, y = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3 4 5\n```\n\n\n:::\n\n```{.r .cell-code}\n10:13 |> `%%`(hoge = _, 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 0 1\n```\n\n\n:::\n\n```{.r .cell-code}\nc(TRUE, FALSE, NA, TRUE, TRUE, FALSE) |>\n  `&`(lhs = _, rhs = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE FALSE    NA  TRUE  TRUE FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\n1:3 |> `>`(2, with = _) # 2 > 1:3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE FALSE FALSE\n```\n\n\n:::\n:::\n\n\nちなみに、`!`は呼び出してみると以下のようになります。\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n`!`\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nfunction (x)  .Primitive(\"!\")\n```\n\n\n:::\n:::\n\n引数名が`x`になっています。というわけで最初の例で挙げた書き方（`e1 = _`）の時点で実は引数名が何でもよいことになっていました。\n\n#### `magrittr` aliases\nここまで書いておいて今更感があるんですが、実はこれらの演算子がパイプで使えるように`magrittr`パッケージではエイリアスが用意されています。例えば`+`は`magrittr::add()`で書くことができます。中身も同じです。\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmagrittr::add\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nfunction (e1, e2)  .Primitive(\"+\")\n```\n\n\n:::\n:::\n\n\nその他の演算子については`help(\"extract\", package = \"magrittr\")`で見れます。\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n1:3 |> add(2) # same as `+`\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3 4 5\n```\n\n\n:::\n\n```{.r .cell-code}\n10:13 |> mod(hoge = _, 3) # same as `%%`\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 0 1\n```\n\n\n:::\n\n```{.r .cell-code}\nc(TRUE, FALSE, NA, TRUE, TRUE, FALSE) |> not(x = _) # same as `!`\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE  TRUE    NA FALSE FALSE  TRUE\n```\n\n\n:::\n:::\n\n正直言うと、これらエイリアスを使った方がわかりやすさも可読性もがいいように思います。なお、`tidyverse`パッケージを使っている人であれば`magrittr`は必ずインストールされていますが、基本パッケージではないので`library(tidyverse)`だけでは呼び出し(`::`)なしで使えません。使いたい人は`library(magrittr)`もついでにしてください。\n\n### Supplement\n参考までに、足し算だけ処理速度の比較をしてみます。基本的な記法、ネイティブパイプ、magrittrエイリアス、magrittrパイプの4記法で比較です。ネタバレするとあまりにも速すぎるので、試行回数は1万回にしてもすぐ終わります。\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nres_bench_n3 <- microbenchmark::microbenchmark(\n  \"basic\" = {1:3 + 2},\n  \"native_pipe\" = {1:3 |> `+`(x = _, 2)},\n  \"magrittr_alias\" ={1:3 |> add(2)},\n  \"magrittr_pipe\" = {1:3 %>% `+`(2)},\n  check = \"equal\",\n  times = 10000\n)\n\nres_bench_n3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nUnit: nanoseconds\n           expr  min   lq    mean median   uq   max neval cld\n          basic  100  100  184.02    200  200 20800 10000 a  \n    native_pipe  100  100  184.02    200  200 24900 10000 a  \n magrittr_alias  100  100  207.64    200  200 24400 10000  b \n  magrittr_pipe 1300 1400 1515.64   1500 1500 25300 10000   c\n```\n\n\n:::\n\n```{.r .cell-code}\nggplot2::autoplot(res_bench_n3)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-28-1.png){fig-align='center' width=672}\n:::\n:::\n\nこの中だとmagrittrパイプだけが非常に遅いです。ちなみにキャッシュを使っていないので、レンダリングするたびにベンチマークの結果が変わるのですが（ネイティブパイプとmagrittrエイリアスに差があることになったりならなかったり）、magrittrパイプが遅いのだけは変わらないです。ただし、この結果の単位はナノ秒です。体感できる差ではありません。\n\nベクトルの要素を1万個まで増やして再度比較します。\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nres_bench_n10k <- microbenchmark::microbenchmark(\n  \"basic\" = {1:10000 + 123},\n  \"native_pipe\" = {1:10000 |> `+`(x = _, 123)},\n  \"magrittr_alias\" ={1:10000 |> add(123)},\n  \"magrittr_pipe\" = {1:10000 %>% `+`(123)},\n  check = \"equal\",\n  times = 10000\n)\n\nres_bench_n10k\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nUnit: microseconds\n           expr  min   lq     mean median   uq      max neval cld\n          basic  9.4 10.4 15.63672   10.8 11.5   3042.0 10000   a\n    native_pipe  9.4 10.4 61.00143   10.8 11.5 117682.7 10000   a\n magrittr_alias  9.5 10.5 28.25475   10.9 11.5 111963.6 10000   a\n  magrittr_pipe 10.8 12.2 30.34975   12.7 13.6 112676.1 10000   a\n```\n\n\n:::\n\n```{.r .cell-code}\nggplot2::autoplot(res_bench_n10k)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-29-1.png){fig-align='center' width=672}\n:::\n:::\n\nmagrittrパイプの分布が若干他3記法よりも後ろにあるように見受けられますが、単位はマイクロ秒ですしこれも体感できる差があるとは言えないでしょう。\n\n## Conclusion\nネイティブパイプのRHSで特別な演算子を使ってみたという話でした。調べてもでてこなくて、最初見つけたときはすごくときめいた感じがしたのですが、これを書いている間にどんどん「だからどうした」感が出てたのと、なんでパイプラインで論理値反転したかったのかをすっかり忘れました。まあ、こういう書き方もできるよということで。\n\n## Session Infomation\n\n:::{.callout-note collapse=true title=\"sessioninfo\"}\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output .cell-output-stdout}\n\n```\nR version 4.5.2 (2025-10-31 ucrt)\nPlatform: x86_64-w64-mingw32/x64\nRunning under: Windows 11 x64 (build 26100)\n\nMatrix products: default\n  LAPACK version 3.12.1\n\nlocale:\n[1] LC_COLLATE=Japanese_Japan.utf8  LC_CTYPE=Japanese_Japan.utf8    LC_MONETARY=Japanese_Japan.utf8\n[4] LC_NUMERIC=C                    LC_TIME=Japanese_Japan.utf8    \n\ntime zone: Asia/Tokyo\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] magrittr_2.0.4\n\nloaded via a namespace (and not attached):\n [1] Matrix_1.7-4         gtable_0.3.6         jsonlite_2.0.0       dplyr_1.2.0         \n [5] compiler_4.5.2       tidyselect_1.2.1     splines_4.5.2        systemfonts_1.3.1   \n [9] scales_1.4.0         textshaping_1.0.4    yaml_2.3.12          fastmap_1.2.0       \n[13] TH.data_1.1-5        lattice_0.22-7       ggplot2_4.0.2        R6_2.6.1            \n[17] labeling_0.4.3       generics_0.1.4       microbenchmark_1.5.0 knitr_1.51          \n[21] MASS_7.3-65          htmlwidgets_1.6.4    tibble_3.3.1         pillar_1.11.1       \n[25] RColorBrewer_1.1-3   rlang_1.1.7          multcomp_1.4-29      xfun_0.56           \n[29] S7_0.2.1             otel_0.2.0           cli_3.6.5            withr_3.0.2         \n[33] digest_0.6.39        grid_4.5.2           mvtnorm_1.3-3        rstudioapi_0.18.0   \n[37] sandwich_3.1-1       lifecycle_1.0.5      vctrs_0.7.1          evaluate_1.0.5      \n[41] glue_1.8.0           farver_2.1.2         codetools_0.2-20     ragg_1.5.0          \n[45] zoo_1.8-15           survival_3.8-3       rmarkdown_2.30       tools_4.5.2         \n[49] pkgconfig_2.0.3      htmltools_0.5.9     \n```\n\n\n:::\n:::\n\n\n:::",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}