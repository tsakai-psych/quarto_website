{
  "hash": "d6f55aeee0864264268b085d623220c2",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"dplyr::rowwiseを使わないで個人の尺度得点を算出する\"\ndate: 2025-11-02\nabstract: |\n  `dplyr::rowwise()`を使わずに、個人の尺度得点を算出する方法を試してみた。`rowMeans(pick(...))`が速くていいかも。\ncategories: [R memo, preprocess]\nformat:\n  html:\n    fig-dpi: 200\nknitr:\n  opts_chunk: \n    fig.align: center\n    R.options:\n      width: 110\neditor_options: \n  chunk_output_type: console\n---\n\n# Packages\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npacman::p_load(\n  tidyverse,\n  psych,\n  microbenchmark\n)\n```\n:::\n\n\n# Contents\ntidyverseの関数群を使って心理学のデータの処理をするとして、各個人の尺度得点をそれぞれ出したい場合はおそらく`dplyr::rowwise()`とそれに関連する関数を使って処理すると思います。今回は別のアプローチでトライしてみました。\n\n## demo data\n`psych::bfi`がちょうどいいので、逆転処理などをしておいてデモデータにします。\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"true\"}\ndf_bfi <- \n  psych::bfi |>\n  relocate(\n    gender, education, age\n  ) |>\n  rownames_to_column(var = \"id\") |>\n  mutate(\n    across(\n      .cols = all_of(\n        unlist(bfi.keys) |>\n          str_subset(pattern = \"^-\") |> # extract reverse item\n          str_remove(pattern = \"^-\")\n      ),\n      .fns = \\(x) {7 - x} # six point scale, so subtract from seven.\n    )\n  ) |>\n  rename( # <1>\n    q_education = education,  # <1>\n    q_age = age, # <1>\n    q_gender = gender # <1>\n  ) |> # <1>\n  as_tibble() # for better printing\n```\n:::\n\n1. わざわざ列名を変えなくてもいいのですが、`tidyselect::starts_with()`でいちいち`ignore.case = TRUE`としないとageとA\\*、educationとE\\*の区別をつけてもらえなくてめんどくさいので、変えておきます。\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndf_bfi\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2,800 × 29\n   id    q_gender q_education q_age    A1    A2    A3    A4    A5    C1    C2    C3    C4    C5    E1    E2\n   <chr>    <int>       <int> <int> <dbl> <int> <int> <int> <int> <int> <int> <int> <dbl> <dbl> <dbl> <dbl>\n 1 61617        1          NA    16     5     4     3     4     4     2     3     3     3     3     4     4\n 2 61618        2          NA    18     5     4     5     2     5     5     4     4     4     3     6     6\n 3 61620        2          NA    17     2     4     5     4     4     4     5     4     5     2     5     3\n 4 61621        2          NA    17     3     4     6     5     5     4     4     3     2     2     2     4\n 5 61622        1          NA    17     5     3     3     4     5     4     4     5     4     5     5     5\n 6 61623        2           3    21     1     6     5     6     5     6     6     6     6     4     5     6\n 7 61624        1          NA    18     5     5     5     3     5     5     4     4     5     4     3     4\n 8 61629        1           2    19     3     3     1     5     1     3     2     4     5     3     4     1\n 9 61630        1           1    19     3     3     6     3     3     6     6     3     3     2     2     4\n10 61633        2          NA    17     5     5     6     6     5     6     5     6     5     6     5     5\n# ℹ 2,790 more rows\n# ℹ 13 more variables: E3 <int>, E4 <int>, E5 <int>, N1 <int>, N2 <int>, N3 <int>, N4 <int>, N5 <int>,\n#   O1 <int>, O2 <dbl>, O3 <int>, O4 <int>, O5 <dbl>\n```\n\n\n:::\n:::\n\n\n## `rowwise()`\n心理学のデータ処理で因子分析とα係数の確認を終えたら、次に行うのは尺度得点の計算だと思います。参加者ごとに下位尺度の得点を算出していくのですが、その場合は調べてみるとたいていは`dplyr::rowise()`[^rowwise]と`dplyr::c_across()`[^c_across]を使った処理に行き着くと思います。つまり、`rowwise()`で行ごとにグルーピングして、`c_across`でまとめたい要素をまとめて、それで処理するという方法です。\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndf_bfi |>\n  rowwise() |>\n  mutate(\n    score_A = mean(c_across(starts_with(\"A\"))),\n    score_C = mean(c_across(starts_with(\"C\"))),\n    score_E = mean(c_across(starts_with(\"E\"))),\n    score_N = mean(c_across(starts_with(\"N\"))),\n    score_O = mean(c_across(starts_with(\"O\"))),\n    .after = q_age\n  ) |>\n  ungroup()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2,800 × 34\n   id    q_gender q_education q_age score_A score_C score_E score_N score_O    A1    A2    A3    A4    A5\n   <chr>    <int>       <int> <int>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl> <dbl> <int> <int> <int> <int>\n 1 61617        1          NA    16     4       2.8     3.8     2.8     3       5     4     3     4     4\n 2 61618        2          NA    18     4.2     4       5       3.8     4       5     4     5     2     5\n 3 61620        2          NA    17     3.8     4       4.2     3.6     4.8     2     4     5     4     4\n 4 61621        2          NA    17     4.6     3       3.6     2.8     3.2     3     4     6     5     5\n 5 61622        1          NA    17     4       4.4     4.8     3.2     3.6     5     3     3     4     5\n 6 61623        2           3    21     4.6     5.6     5.6     3       5       1     6     5     6     5\n 7 61624        1          NA    18     4.6     4.4     4.2     1.4     5.4     5     5     5     3     5\n 8 61629        1           2    19     2.6     3.4     2.4     4.2     4.2     3     3     1     5     1\n 9 61630        1           1    19     3.6     4      NA       3.6     5       3     3     6     3     3\n10 61633        2          NA    17     5.4     5.6     4.8     4.2     5.2     5     5     6     6     5\n# ℹ 2,790 more rows\n# ℹ 20 more variables: C1 <int>, C2 <int>, C3 <int>, C4 <dbl>, C5 <dbl>, E1 <dbl>, E2 <dbl>, E3 <int>,\n#   E4 <int>, E5 <int>, N1 <int>, N2 <int>, N3 <int>, N4 <int>, N5 <int>, O1 <int>, O2 <dbl>, O3 <int>,\n#   O4 <int>, O5 <dbl>\n```\n\n\n:::\n:::\n\nこれで処理できるのでそれはそれでいいのですが、いくつか気になる点があります。\n\n1. `dplyr::ungroup()`が必要\n\n    `ungroup()`を忘れるとrowwiseグループが維持されるので、その後の処理で面倒なことが起こる可能性があります。\n\n2. 行数によっては遅い\n\n    行数が少なければ気にならないと思いますが、行数が多いデータだと`rowwise()`処理は体感できるレベルで遅いです。今回の2800行のデータだと4秒程度かかります。\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmicrobenchmark::microbenchmark(\n  \"rowwise\" = {\n    df_bfi |>\n      rowwise() |>\n      mutate(\n        score_A = mean(c_across(starts_with(\"A\"))),\n        score_C = mean(c_across(starts_with(\"C\"))),\n        score_E = mean(c_across(starts_with(\"E\"))),\n        score_N = mean(c_across(starts_with(\"N\"))),\n        score_O = mean(c_across(starts_with(\"O\"))),\n        .after = q_age\n      ) |>\n      ungroup()\n  },\n  times = 5L # <1>\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nUnit: seconds\n    expr      min       lq     mean   median       uq      max neval\n rowwise 4.379653 4.452662 4.606178 4.665492 4.692358 4.840726     5\n```\n\n\n:::\n:::\n\n1. レンダリングの際にこの処理だけであまりにも時間がかかるので、ベンチマークの反復はデフォルトの100回から5回に減らしました。\n\nというわけで、別のやり方がないか模索したわけです。\n\n[^rowwise]: <https://dplyr.tidyverse.org/reference/rowwise.html>\n[^c_across]: <https://dplyr.tidyverse.org/reference/c_across.html>\n\n## `.by` argument\nグルーピングに`.by`[^dplyr_by]引数を用いるやり方です。`dplyr::group_by()`や`rowwise`は関数としてパイプフローに組み込んで、処理の後もグルーピングを維持するのに対して`.by = ...`/`by = ...`は処理の関数の引数で設定し、その処理限りのグルーピングを行います。戻ってくるdataframeはグループ化されていないので、個人的にはその後の処理がやりやすい感じがしてよく使っています。変数選択にはtidy-selectの文法が使えます。\n\nなお、`.by`引数に突っ込める`rowwise()`ってある？という質問が[Posit Communityのforum](https://forum.posit.co/t/whats-a-good-way-to-replicate-rowwise-within-the-by-argument-of-mutate/168538)に投げられているのですが、悲しいことに回答なしでclosedになっています。おそらく現時点ではそのようなものは実装されてないみたいなので、質問者の方が提示しているように`.by`には一意のID列を設定すればいいのだと思います。\nそして、このID列を`.by`に入れたときは実質rowwise処理になるので、なんと`c_across()`がちゃんと動きます。\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndf_bfi |>\n  mutate(\n      score_A = mean(c_across(starts_with(\"A\"))),\n      score_C = mean(c_across(starts_with(\"C\"))),\n      score_E = mean(c_across(starts_with(\"E\"))),\n      score_N = mean(c_across(starts_with(\"N\"))),\n      score_O = mean(c_across(starts_with(\"O\"))),\n      .after = q_age,\n      .by = id\n    )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2,800 × 34\n   id    q_gender q_education q_age score_A score_C score_E score_N score_O    A1    A2    A3    A4    A5\n   <chr>    <int>       <int> <int>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl> <dbl> <int> <int> <int> <int>\n 1 61617        1          NA    16     4       2.8     3.8     2.8     3       5     4     3     4     4\n 2 61618        2          NA    18     4.2     4       5       3.8     4       5     4     5     2     5\n 3 61620        2          NA    17     3.8     4       4.2     3.6     4.8     2     4     5     4     4\n 4 61621        2          NA    17     4.6     3       3.6     2.8     3.2     3     4     6     5     5\n 5 61622        1          NA    17     4       4.4     4.8     3.2     3.6     5     3     3     4     5\n 6 61623        2           3    21     4.6     5.6     5.6     3       5       1     6     5     6     5\n 7 61624        1          NA    18     4.6     4.4     4.2     1.4     5.4     5     5     5     3     5\n 8 61629        1           2    19     2.6     3.4     2.4     4.2     4.2     3     3     1     5     1\n 9 61630        1           1    19     3.6     4      NA       3.6     5       3     3     6     3     3\n10 61633        2          NA    17     5.4     5.6     4.8     4.2     5.2     5     5     6     6     5\n# ℹ 2,790 more rows\n# ℹ 20 more variables: C1 <int>, C2 <int>, C3 <int>, C4 <dbl>, C5 <dbl>, E1 <dbl>, E2 <dbl>, E3 <int>,\n#   E4 <int>, E5 <int>, N1 <int>, N2 <int>, N3 <int>, N4 <int>, N5 <int>, O1 <int>, O2 <dbl>, O3 <int>,\n#   O4 <int>, O5 <dbl>\n```\n\n\n:::\n:::\n\n先ほどの`rowwise()`の書き方と全く同じ結果が返ってきています。ID列をちゃんと作ってあれば、`.by`引数にそれを入れることでもできるわけです。\nただし、実はこの方法も時間がかかる処理で、`rowwise()`のときと同じくらいの処理時間がかかります。\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"true\"}\nmicrobenchmark::microbenchmark(\n  \".by\" = {\n    df_bfi |>\n      mutate(\n        score_A = mean(c_across(starts_with(\"A\"))),\n        score_C = mean(c_across(starts_with(\"C\"))),\n        score_E = mean(c_across(starts_with(\"E\"))),\n        score_N = mean(c_across(starts_with(\"N\"))),\n        score_O = mean(c_across(starts_with(\"O\"))),\n        .after = q_age,\n        .by = id\n      )\n  },\n  times = 5L # for saving time\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nUnit: seconds\n expr      min       lq     mean   median       uq     max neval\n  .by 4.452133 4.503107 4.554612 4.581422 4.597017 4.63938     5\n```\n\n\n:::\n:::\n\n\n[^dplyr_by]: <https://dplyr.tidyverse.org/reference/dplyr_by.html>\n\n## `rowMeans(pick(...))`\n上記の`.by`引数に突っ込める`rowwise()`みたいな関数ってないのかな～と探していたときに、たまたまこんな記事を見つけました。\n\n- [Row-wise means in dplyr](https://affcom.ku.edu/posts/rowwise2023/)\n\n`base::rowMeans()`に`dplyr::pick()`[^pick]で列を選択して入れるという技です。`pick()`は`mutate()`や`dplyr::summrise()`のような関数の中でtidy-selectの文法を使ってdataframe列を選択できる関数です。`pick()`の戻り値がdataframeであること、`rowMeans()`は引数にdataframeも入れられること、`rowMeans()`の戻り値は各行の値の平均値を収めたベクトルであることを利用して、`rowwise()`を使わずに実質的にrowwise処理をしてしまおうというわけですね。\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndf_bfi |>\n  mutate(\n    score_A = rowMeans(pick(starts_with(\"A\"))),\n    score_C = rowMeans(pick(starts_with(\"C\"))),\n    score_E = rowMeans(pick(starts_with(\"E\"))),\n    score_N = rowMeans(pick(starts_with(\"N\"))),\n    score_O = rowMeans(pick(starts_with(\"O\"))),\n    .after = q_age\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2,800 × 34\n   id    q_gender q_education q_age score_A score_C score_E score_N score_O    A1    A2    A3    A4    A5\n   <chr>    <int>       <int> <int>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl> <dbl> <int> <int> <int> <int>\n 1 61617        1          NA    16     4       2.8     3.8     2.8     3       5     4     3     4     4\n 2 61618        2          NA    18     4.2     4       5       3.8     4       5     4     5     2     5\n 3 61620        2          NA    17     3.8     4       4.2     3.6     4.8     2     4     5     4     4\n 4 61621        2          NA    17     4.6     3       3.6     2.8     3.2     3     4     6     5     5\n 5 61622        1          NA    17     4       4.4     4.8     3.2     3.6     5     3     3     4     5\n 6 61623        2           3    21     4.6     5.6     5.6     3       5       1     6     5     6     5\n 7 61624        1          NA    18     4.6     4.4     4.2     1.4     5.4     5     5     5     3     5\n 8 61629        1           2    19     2.6     3.4     2.4     4.2     4.2     3     3     1     5     1\n 9 61630        1           1    19     3.6     4      NA       3.6     5       3     3     6     3     3\n10 61633        2          NA    17     5.4     5.6     4.8     4.2     5.2     5     5     6     6     5\n# ℹ 2,790 more rows\n# ℹ 20 more variables: C1 <int>, C2 <int>, C3 <int>, C4 <dbl>, C5 <dbl>, E1 <dbl>, E2 <dbl>, E3 <int>,\n#   E4 <int>, E5 <int>, N1 <int>, N2 <int>, N3 <int>, N4 <int>, N5 <int>, O1 <int>, O2 <dbl>, O3 <int>,\n#   O4 <int>, O5 <dbl>\n```\n\n\n:::\n:::\n\nこれもまた今までの書き方と同じ結果が返ってきています。`mean()`が`rowMeans`に、`c_across()`が`pick()`に変わっただけなので、コードの可読性も悪くない気がします。\n\nそして処理速度ですが、上記２つに比べてとても速いです。\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"true\"}\nmicrobenchmark::microbenchmark(\n  \"base::rowMeans\" = {\n    df_bfi |>\n      mutate(\n        score_A = rowMeans(pick(starts_with(\"A\"))),\n        score_C = rowMeans(pick(starts_with(\"C\"))),\n        score_E = rowMeans(pick(starts_with(\"E\"))),\n        score_N = rowMeans(pick(starts_with(\"N\"))),\n        score_O = rowMeans(pick(starts_with(\"O\"))),\n        .after = q_age\n      )\n  }\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nUnit: milliseconds\n           expr    min    lq     mean median    uq    max neval\n base::rowMeans 4.3955 4.775 5.446678 5.0946 5.985 9.3616   100\n```\n\n\n:::\n:::\n\n上記2つは単位が秒だったのに、こちらの単位はミリ秒です。つまり、4ミリ秒程度で処理が終わっています。\n\nちなみに、もし各項目の合計得点が尺度得点である場合は、`base::rowSums()`を使えばいいです。\n\n[^pick]: <https://dplyr.tidyverse.org/reference/pick.html>\n\n## `apply(MARGIN = 1)`\nそういえば、行での計算は`base::apply(MARGIN = 1)`でもできるのを思い出しました。引数には同じく`pick()`で選んだ列を入れて、関数に`mean()`を選択すれば同じ結果が得られるはずです。\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndf_bfi |>\n  mutate(\n    score_A = apply(\n      pick(starts_with(\"A\")),\n      MARGIN = 1,\n      FUN = mean\n    ),\n    score_C = apply(\n      pick(starts_with(\"C\")),\n      MARGIN = 1,\n      FUN = mean\n    ),\n    score_E = apply(\n      pick(starts_with(\"E\")),\n      MARGIN = 1,\n      FUN = mean\n    ),\n    score_N = apply(\n      pick(starts_with(\"N\")),\n      MARGIN = 1,\n      FUN = mean\n    ),\n    score_O = apply(\n      pick(starts_with(\"O\")),\n      MARGIN = 1,\n      FUN = mean\n    ),\n    .after = q_age\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2,800 × 34\n   id    q_gender q_education q_age score_A score_C score_E score_N score_O    A1    A2    A3    A4    A5\n   <chr>    <int>       <int> <int>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl> <dbl> <int> <int> <int> <int>\n 1 61617        1          NA    16     4       2.8     3.8     2.8     3       5     4     3     4     4\n 2 61618        2          NA    18     4.2     4       5       3.8     4       5     4     5     2     5\n 3 61620        2          NA    17     3.8     4       4.2     3.6     4.8     2     4     5     4     4\n 4 61621        2          NA    17     4.6     3       3.6     2.8     3.2     3     4     6     5     5\n 5 61622        1          NA    17     4       4.4     4.8     3.2     3.6     5     3     3     4     5\n 6 61623        2           3    21     4.6     5.6     5.6     3       5       1     6     5     6     5\n 7 61624        1          NA    18     4.6     4.4     4.2     1.4     5.4     5     5     5     3     5\n 8 61629        1           2    19     2.6     3.4     2.4     4.2     4.2     3     3     1     5     1\n 9 61630        1           1    19     3.6     4      NA       3.6     5       3     3     6     3     3\n10 61633        2          NA    17     5.4     5.6     4.8     4.2     5.2     5     5     6     6     5\n# ℹ 2,790 more rows\n# ℹ 20 more variables: C1 <int>, C2 <int>, C3 <int>, C4 <dbl>, C5 <dbl>, E1 <dbl>, E2 <dbl>, E3 <int>,\n#   E4 <int>, E5 <int>, N1 <int>, N2 <int>, N3 <int>, N4 <int>, N5 <int>, O1 <int>, O2 <dbl>, O3 <int>,\n#   O4 <int>, O5 <dbl>\n```\n\n\n:::\n:::\n\nこれまでの方法と同じ結果が返ってきました。`apply()`は引数`MARGIN`に入れるのって0or1だっけ1or2だっけ？どっちが行でどっちが列だっけ？となるので、あんまり使ってないです。（覚えればいいんですけど指定は1or2で、1が行に対して、2が列に対しての計算です。）\n\n処理速度に関してはどうでしょうか。\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"true\"}\nmicrobenchmark::microbenchmark(\n  \"apply_margin1\" = {\n    df_bfi |>\n      mutate(\n        score_A = apply(\n          pick(starts_with(\"A\")),\n          MARGIN = 1,\n          FUN = mean\n        ),\n        score_C = apply(\n          pick(starts_with(\"C\")),\n          MARGIN = 1,\n          FUN = mean\n        ),\n        score_E = apply(\n          pick(starts_with(\"E\")),\n          MARGIN = 1,\n          FUN = mean\n        ),\n        score_N = apply(\n          pick(starts_with(\"N\")),\n          MARGIN = 1,\n          FUN = mean\n        ),\n        score_O = apply(\n          pick(starts_with(\"O\")),\n          MARGIN = 1,\n          FUN = mean\n        ),\n        .after = q_age\n      )\n  }\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nUnit: milliseconds\n          expr     min       lq    mean median      uq      max neval\n apply_margin1 69.1538 72.07505 75.1989 73.648 76.3195 178.5305   100\n```\n\n\n:::\n:::\n\n`bfi`データだと70ミリ秒くらいで済むみたいです。`rowMeans()`よりは遅いですが、`rowwise()`と`.by`よりは速いみたいですね。\n\n## Comparison\nせっかくなので処理速度を一度に比べてみます。ただし、このまま`bfi`データでベンチマークするととんでもない時間がかかるので、もっと数が少ない`iris`データで比較します。\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndf_iris <- iris |>\n  as_tibble() |> # for better printing\n  rowid_to_column() # for equal results\n\nhead(df_iris)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 6\n  rowid Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n  <int>        <dbl>       <dbl>        <dbl>       <dbl> <fct>  \n1     1          5.1         3.5          1.4         0.2 setosa \n2     2          4.9         3            1.4         0.2 setosa \n3     3          4.7         3.2          1.3         0.2 setosa \n4     4          4.6         3.1          1.5         0.2 setosa \n5     5          5           3.6          1.4         0.2 setosa \n6     6          5.4         3.9          1.7         0.4 setosa \n```\n\n\n:::\n:::\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"true\"}\nres <- microbenchmark::microbenchmark(\n  \"rowwise\" = {\n    df_iris |>\n      rowwise() |>\n      mutate(\n        sepal = mean(c_across(starts_with(\"Sepal\"))),\n        petal = mean(c_across(starts_with(\"Petal\")))\n      ) |>\n      ungroup()\n  },\n  \".by\" = {\n    df_iris |>\n      mutate(\n        sepal = mean(c_across(starts_with(\"Sepal\"))),\n        petal = mean(c_across(starts_with(\"Petal\"))),\n        .by = rowid\n      )\n  },\n  \"rowMeans\" = {\n    df_iris |>\n      mutate(\n        sepal = rowMeans(pick(starts_with(\"Sepal\"))),\n        petal = rowMeans(pick(starts_with(\"Petal\")))\n      )\n  },\n  \"apply_margin1\" = {\n    df_iris |>\n      mutate(\n        sepal = apply(\n          pick(starts_with(\"Sepal\")),\n          MARGIN = 1,\n          FUN = mean\n        ),\n        petal = apply(\n          pick(starts_with(\"Petal\")),\n          MARGIN = 1,\n          FUN = mean\n        )\n      )\n  },\n  check = \"equal\"\n)\n\nres\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nUnit: milliseconds\n          expr     min       lq      mean  median       uq      max neval cld\n       rowwise 83.6199 87.56705 92.048610 90.2374 93.21040 198.1570   100 a  \n           .by 81.9493 85.52320 89.220028 87.6496 90.60810 108.6058   100  b \n      rowMeans  1.4587  1.56730  1.722859  1.6520  1.73630   4.0320   100   c\n apply_margin1  2.8520  2.99130  3.212039  3.0942  3.26395   5.5633   100   c\n```\n\n\n:::\n:::\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nautoplot(res)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/preview-1.png){fig-align='center' width=1400}\n:::\n:::\n\n圧倒的に`rowMeans()`が速いです。桁が違います。元記事の比較データだと、10000行のデータでも`rowMeans()`を使う方法が圧倒的に速いです。`dplyr`のarticle（[Row-wise operations](https://dplyr.tidyverse.org/articles/rowwise.html?q=rowwise#row-wise-summary-functions)）にも書いてありましたが、速さを求めるならこっちと言うのもわかります。base関数はやはり侮れません。`apply()`も行数が少なければ高速っぽいです。\n\n:::{.callout-tip collapse=\"true\"}\n### 番外編：`Rfast::rowmeans()`\n同じノリで`Rfast::rowmeans()`もイケるか…？と思って試してみました。`Rfast`[^Rfast]パッケージの関数は基本はmatrixかつ`NA`なしじゃないと使えない（内部で使ってるCppの都合で`NA`があると良くないとのこと）のですが、Helpを見る限り`rowmeans()`はdataframeでも計算してくれそうな感じっぽいので試してみました。\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndf_bfi |>\n  mutate(\n    score_A = Rfast::rowmeans(pick(starts_with(\"A\")))\n  )\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in `mutate()`:\nℹ In argument: `score_A = Rfast::rowmeans(pick(starts_with(\"A\")))`.\nCaused by error:\n! Not compatible with requested type: [type=list; target=double].\n```\n\n\n:::\n:::\n\nダメでした。ということで、無理やりmatrixにして再挑戦します。\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndf_bfi |>\n  mutate(\n    score_A = pick(starts_with(\"A\")) |>\n      as.matrix() |>\n      Rfast::rowmeans(),\n    .after = q_age\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2,800 × 30\n   id    q_gender q_education q_age score_A    A1    A2    A3    A4    A5    C1    C2    C3    C4    C5    E1\n   <chr>    <int>       <int> <int>   <dbl> <dbl> <int> <int> <int> <int> <int> <int> <int> <dbl> <dbl> <dbl>\n 1 61617        1          NA    16     4       5     4     3     4     4     2     3     3     3     3     4\n 2 61618        2          NA    18     4.2     5     4     5     2     5     5     4     4     4     3     6\n 3 61620        2          NA    17     3.8     2     4     5     4     4     4     5     4     5     2     5\n 4 61621        2          NA    17     4.6     3     4     6     5     5     4     4     3     2     2     2\n 5 61622        1          NA    17     4       5     3     3     4     5     4     4     5     4     5     5\n 6 61623        2           3    21     4.6     1     6     5     6     5     6     6     6     6     4     5\n 7 61624        1          NA    18     4.6     5     5     5     3     5     5     4     4     5     4     3\n 8 61629        1           2    19     2.6     3     3     1     5     1     3     2     4     5     3     4\n 9 61630        1           1    19     3.6     3     3     6     3     3     6     6     3     3     2     2\n10 61633        2          NA    17     5.4     5     5     6     6     5     6     5     6     5     6     5\n# ℹ 2,790 more rows\n# ℹ 14 more variables: E2 <dbl>, E3 <int>, E4 <int>, E5 <int>, N1 <int>, N2 <int>, N3 <int>, N4 <int>,\n#   N5 <int>, O1 <int>, O2 <dbl>, O3 <int>, O4 <int>, O5 <dbl>\n```\n\n\n:::\n:::\n\nできました。でも、わざわざmatrixにしなきゃいけいないのはめんどくさいです。\n\nちなみに、`bfi`データの場合、`rowMeans()`の方法と処理時間には差がつきません。同じくらい速いです。\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"true\"}\nmicrobenchmark::microbenchmark(\n  \"base::rowMeans\" = {\n    df_bfi |>\n      mutate(\n        score_A = rowMeans(pick(starts_with(\"A\"))),\n        score_C = rowMeans(pick(starts_with(\"C\"))),\n        score_E = rowMeans(pick(starts_with(\"E\"))),\n        score_N = rowMeans(pick(starts_with(\"N\"))),\n        score_O = rowMeans(pick(starts_with(\"O\"))),\n        .after = q_age\n      )\n  },\n  \"Rfast::rowmeans\" = {\n    df_bfi |>\n      mutate(\n        score_A = pick(starts_with(\"A\")) |>\n          as.matrix() |>\n          Rfast::rowmeans(),\n        score_C = pick(starts_with(\"C\")) |>\n          as.matrix() |>\n          Rfast::rowmeans(),\n        score_E = pick(starts_with(\"E\")) |>\n          as.matrix() |>\n          Rfast::rowmeans(),\n        score_N = pick(starts_with(\"N\")) |>\n          as.matrix() |>\n          Rfast::rowmeans(),\n        score_O = pick(starts_with(\"O\")) |>\n          as.matrix() |>\n          Rfast::rowmeans(),\n        .after = q_age\n      )\n  }\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nUnit: milliseconds\n            expr    min      lq     mean median     uq    max neval cld\n  base::rowMeans 4.2664 4.34500 4.555280 4.4065 4.5439 8.7891   100   a\n Rfast::rowmeans 4.2167 4.28615 4.673185 4.3685 4.5172 8.2862   100   a\n```\n\n\n:::\n:::\n\n\n`ggplot2::diamonds`は約54000行あるんですが、計算させてみると`rowMeans()`よりも微妙に速かったりします。ただし1ミリ秒も差がつかないので体感できないです。\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmicrobenchmark::microbenchmark(\n  \"base::rowMeans\" = {\n    diamonds |>\n      mutate(\n        res = pick(depth:z) |>\n          rowMeans()\n      )\n  },\n  \"Rfast::rowmeans\" = {\n    diamonds |>\n      mutate(\n        res = pick(depth:z) |>\n          as.matrix() |>\n          Rfast::rowmeans()\n      )\n  },\n  check = \"equal\"\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nUnit: milliseconds\n            expr    min      lq     mean  median      uq    max neval cld\n  base::rowMeans 2.2124 2.37665 2.779288 2.51615 2.70125 5.3981   100  a \n Rfast::rowmeans 1.5674 1.70840 2.082682 1.83450 2.08915 6.0799   100   b\n```\n\n\n:::\n:::\n\nものすごくデータ数が多いときなら、選択肢に入る方法かもしれません。\n:::\n\n[^Rfast]: <https://github.com/RfastOfficial/Rfast?tab=readme-ov-file#readme>\n\n# Conclusion\n今回はwideなデータにおいて`dplyr::rowwise()`を使わないで尺度得点の算出というrowwiseな処理をしてみました。個人的には`base::row*(pick(...))`を使うのもありだと思いました。可読性もそんなに悪くないと思います。一方で、個人ごとに計算しているというのを明示したい場合は、`rowwise()`を挟んだり`.by = ID列`の方が分かりやすい気もします。サンプルサイズやコードを共有するか否かなどを考慮して使い分けるのがいいかもしれません。",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}